Revision: 10c4615a119c9ec502c30e3be71cc9eeaa757aa0
Patch-set: 2
File: /COMMIT_MSG

10:32-11:41
Fri Jul 15 16:12:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3ad1308d_1d495f1f
Bytes: 117
It's reserving a large set of bits for a very small number of "users." And it's not extensibly, there's a hard limit.

10:32-11:41
Fri Jul 15 16:18:27 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_1d495f1f
UUID: 6a12f748_5ae395a1
Bytes: 398
You mean the compiler for "users"? Yeah, though you could argue some other bits are also for a very small number of users.

Still we're talking about known methods, and most modifiers are not relevant for them.

What is the problem of using those bits, you think?

Hard limit is currently 255. We could work around using 65535 if you want to, but I doubt the intrinsic maintainer will survive that.

10:32-11:41
Fri Jul 15 16:23:37 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a12f748_5ae395a1
UUID: 3ad1308d_fd2c4b3f
Bytes: 56
No, I meant the number of methods being tagged that way.

10:32-11:41
Fri Jul 15 16:25:37 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_fd2c4b3f
UUID: ba20c083_8441662f
Bytes: 55
Oh I see. Hmm, should I bring up kAccMustCountLocks? :)

14:16-16:18
Fri Jul 15 16:12:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3ad1308d_7d569bbe
Bytes: 74
That's a bug that should be assigned to our class-unloading implementer...

14:16-16:18
Fri Jul 15 16:18:27 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_7d569bbe
UUID: 0af41b40_df1f9b5f
Bytes: 156
Or a bug in the compiler. Regardless, we need to fix it, and I'm in the opinion avoiding a map completely is a nice cleanup.

Do you have other suggestions?

14:16-16:18
Fri Jul 15 16:21:34 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0af41b40_df1f9b5f
UUID: 6a12f748_3ad8e1e9
Bytes: 194
For cleanups that is. We can surely put some hooks between class linker and dex method inliner / compiler driver, but I feel it's much nicer to avoid the map altogeter and not require any hooks.

14:16-16:18
Fri Jul 15 16:23:37 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0af41b40_df1f9b5f
UUID: 3ad1308d_5d1e3704
Bytes: 266
Using a map nicely decouples runtime internals (who don't care that the method can be intrinsified) from the compiler, though. And means that my favorite modes, interpreter and AoT, don't have any "overhead." Maybe an implementation of a sparse map would save space?

14:16-16:18
Fri Jul 15 16:25:37 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_5d1e3704
UUID: 2a08ff1a_182ac5e4
Bytes: 23
Why do you hate svelte?

File: compiler/optimizing/intrinsics.cc

159
Mon Aug 08 13:22:24 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5936f710_e1c2869d
Bytes: 62
You want to rely on the method being already in the dex cache?

File: compiler/optimizing/intrinsics_list.h

2:15-2:27
Mon Aug 08 13:22:24 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f9afab5f_8629aa8f
Bytes: 18
Bulk find&replace?

File: runtime/art_method.h

297:57-297:70
Fri Jul 15 16:23:37 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3ad1308d_bdc49375
Bytes: 22
Why waste another bit?

297:57-297:70
Fri Jul 15 16:25:37 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_bdc49375
UUID: ba20c083_64246aa2
Bytes: 89
? That's the way to know the method is an intrinsic. Not sure I understand your question.

297:57-297:70
Fri Jul 15 16:27:30 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ba20c083_64246aa2
UUID: 3ad1308d_fd90cb66
Bytes: 144
Start counting at 1. That gives you 2^(N+1)-1 intrinsics, vs the 2^N right now. A signalling bit is wasteful when you control the value range...

297:57-297:70
Fri Jul 15 16:31:28 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_fd90cb66
UUID: 0af41b40_7f364fee
Bytes: 109
You don't control the range, other flags are in it. Or maybe I still don't understand what you're suggesting.

297:57-297:70
Fri Jul 15 16:49:15 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0af41b40_7f364fee
UUID: 3ad1308d_4f531e58
Bytes: 131
The value of "intrinsic," make 0 denote "not an intrinsic."

(If you want to "protect" the caller, add one to it before storing...)

297:57-297:70
Fri Jul 15 16:51:01 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_4f531e58
UUID: 6a12f748_5a8a75c3
Bytes: 54
Sorry, still not clear for me. We can take it offline.

