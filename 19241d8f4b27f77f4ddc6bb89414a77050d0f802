Revision: 19241d8f4b27f77f4ddc6bb89414a77050d0f802
Patch-set: 3
File: runtime/debugger.cc

584:10-585:45
Fri Feb 19 12:18:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c2bbb59e_ea2b87c3
Bytes: 13
One per line.

584:10-585:45
Fri Feb 19 17:34:14 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c2bbb59e_ea2b87c3
UUID: 82dc5dfe_76c4685e
Bytes: 4
Done

File: runtime/instrumentation.cc

155:0-155:63
Fri Feb 19 12:18:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 421b45b8_a62ec6d4
Bytes: 201
This looks like the only thing interesting to keep in this method. I would remove everything else: don't bother updating the entrypoint, just expect the runtime to do the interpreter -> jit transition.

155:0-155:63
Fri Feb 19 17:34:14 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 421b45b8_a62ec6d4
UUID: a2d5e1d0_97e1cce6
Bytes: 692
Sorry can you be more specific? We need to install the entry-exit stub as wrapper around quick code. However if there is no quick code that can be used, I install the interpreter bridge (if entry-exit stub is installed, then seems to me there will be double instrumentation happening, one by the entry-exit stub and the other by interpreter).

I also have a question on Instrumentation::UpdateMethodsCode(), which is called by jit to install jitted code in method. However when entry_exit_stubs_installed_ is true, GetQuickInstrumentationEntryPoint() is installed, not jitted code. The entry-exit stub will still call GetQuickCodeFor() to get the oat code to call, instead of the jitted code.

155:0-155:63
Mon Feb 22 09:46:00 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a2d5e1d0_97e1cce6
UUID: c283b51b_8a456b91
Bytes: 158
How about we kill those entry-exit stubs and just rely on the interpreter? With mterp we should get enough performance benefits that I think we can afford it.

