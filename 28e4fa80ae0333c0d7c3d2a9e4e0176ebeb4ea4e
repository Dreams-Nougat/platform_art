Revision: 28e4fa80ae0333c0d7c3d2a9e4e0176ebeb4ea4e
Patch-set: 2
File: runtime/interpreter/mterp/arm/op_float_to_long.S

29
Fri Dec 02 20:14:34 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edf9b7d6_447b4e2c
Bytes: 203
This is more readable than my CL where I'm doing some extra tricks to save instructions in the slow-path. The performance difference is unlikely to matter, so I'm OK to go with this version. Your choice.

29
Fri Dec 02 20:25:15 2016 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edf9b7d6_447b4e2c
UUID: 8d159bc1_2fa14d79
Bytes: 265
OK - I'll confess that I like the "sign bit to carry" trick that allows consolidation of the non-NaN paths and the overall fewer branches.  But, of course, it's all on the exceptional path so it won't matter a bit.  I will change initial branch to follow your lead.

29
Mon Dec 05 10:19:19 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_2fa14d79
UUID: 4d0ba3a9_073af6f5
Bytes: 185
(About the irrelevant...) I admit the ADDS+ADCS+ADC is a nice trick but it does have an unnecessary dependency between the ADCS and ADC. The ASR+EOR+EOR approach avoids that dependency.

29
Mon Dec 05 15:38:38 2016 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d0ba3a9_073af6f5
UUID: 8d159bc1_46e0e30b
Bytes: 290
Good point - and now that I think about it that dependency is trivially avoided by using the adc form rather than adcs form.   If we've got negative infinity, both ads need a 1 carry, otherwise a 0 cary.  And, that's determined by the original adds so no adcs -> adc ripple carry is needed.

29
Mon Dec 05 16:07:41 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_46e0e30b
UUID: 4d4003d4_9f8ad36b
Bytes: 28
Yes, ADDS+ADC+ADC works too.

