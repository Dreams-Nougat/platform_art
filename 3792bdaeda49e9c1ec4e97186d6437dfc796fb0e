Revision: 3792bdaeda49e9c1ec4e97186d6437dfc796fb0e
Patch-set: 1
File: /COMMIT_MSG

12:37-13:16
Fri Oct 07 21:07:16 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7f3ac856_e7dd9667
Bytes: 119
Only true because you killed performance with the previous patch. So I'll have to ask for supporting benchmark numbers.

12:37-13:16
Fri Oct 07 21:08:51 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f3ac856_e7dd9667
UUID: 7f3ac856_2767feb7
Bytes: 61
The object array stuff was not touched by previous patch btw.

File: runtime/mirror/object.cc

90:11-90:39
Fri Oct 07 22:01:18 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7f3ac856_2a30239b
Bytes: 157
We also want the load to be a relaxed atomic load, right? Part of the problem is that a pointer in the source may be getting overwritten while we're copying.

90:11-90:39
Fri Oct 07 22:03:00 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f3ac856_2a30239b
UUID: 7f3ac856_6ab38b03
Bytes: 70
I don't think it makes a difference since word stores are non tearing.

90:11-90:39
Fri Oct 07 22:51:15 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f3ac856_6ab38b03
UUID: 7f3ac856_1090f2fb
Bytes: 381
I think this is good enough to prevent the memcpy recognition. But it's not entirely correct, since a perverse, but conforming, compiler could still, for example, load *src_bytes a byte at a time. If those bytes were concurrently updated by a word-sized write, I could still observe "word-tearing", as some byte reads would see the before value, and some could see the after value.

