Revision: 3ac37b1de35768d4841a7f31a27f959c28af3675
Patch-set: 3
File: /COMMIT_MSG

17:0-19:30
Mon Nov 21 11:23:29 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f0e0b014_ef145d6d
Bytes: 106
I'm sorry, I don't understand this part. Moving to the next level of cache doesn't need write permissions.

17:0-19:30
Mon Nov 21 11:54:39 2016 +0000
Author: Artem Udovichenko <1083288@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0e0b014_ef145d6d
UUID: f0f990d6_ee96902a
Bytes: 241
Probably, dc cvau not only moves to next level of cache, but also makes writes to main memory (as arm documentation says). Due to this instruction uses virtual address it need to translate it into physical address and also check permissions.

17:0-19:30
Mon Nov 21 11:56:51 2016 +0000
Author: Artem Udovichenko <1083288@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0f990d6_ee96902a
UUID: f0f990d6_ae90982d
Bytes: 123
We faced several crashes of such kind. In all cases pc points to this instruction and error code of SIGSEGV was SEGV_ACCERR

17:0-19:30
Mon Nov 21 13:00:19 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0f990d6_ae90982d
UUID: f0e0b014_afc895b5
Bytes: 369
Note that I am not doubting the fix. We here also came to the conclusion it would give us more guarantees to do the flush before the mprotect.

But I think the description you're giving here isn't what is happening. The instruction cache may contain old data at this point, so we flush it, and that cache not doing any updates doesn't need to write back in main memory.

17:0-19:30
Mon Nov 21 15:50:08 2016 +0000
Author: Artem Udovichenko <1083288@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0e0b014_afc895b5
UUID: f0f990d6_6edbc0d9
Bytes: 1405
My thoughts were:
1. We received several crashes described above.
2. If pc points to "dc cvau" inside __aarch64_sync_cache_range in the JIT thread then the JIT thread crashes during flushing of caches.
3. If error code is SEGV_ACCERR then the JIT thread tries to  write into memory which has no write permission. It also means that instruction "dc cvau" can do writes into memory. Arm documentation confirms that.
This commit fixes this issue.

> The instruction cache may contain old data at this point, so we flush it, and that cache not doing any updates doesn't need to write back in main memory.

The issue happens when we flush data cache in the JIT thread.

> But I think the description you're giving here isn't what is happening.


I don't know how it works inside CPU. May be I wrong but, the issue happens on big.little architecture. As I know each core have own L1 cache and common L2 per cluster (4 cores). There is interconnect between L2 caches with support of coherency. For example JIT thread flushes caches on one cluster and this leads to write back from L1 cache into L2 cache. At this moment cache controller invalidates affected cache lines int another cluster and sends data into memory.
I want to say again may be I wrong about CPU logic.


>But I think the description you're giving here isn't what is happening.

Probably we have different issues. Could you explain your opinion?

17:0-19:30
Mon Nov 21 16:10:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0f990d6_6edbc0d9
UUID: f0e0b014_d2fa6454
Bytes: 296
To confirm : when you mention the ART documentation, is it this specific line?
"The AArch64 Data Cache invalidate instruction by address, DC IVAC, requires write permission or else a permission fault is generated."

It's only referencing DC IVAC though, are you saying DC CVAU inherits from this?

17:0-19:30
Mon Nov 21 16:24:48 2016 +0000
Author: Artem Udovichenko <1083288@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0e0b014_d2fa6454
UUID: f0f990d6_ce72b4c2
Bytes: 617
This line
"Cleaning a cache or cache line means writing the contents of cache lines that are marked as dirty, out to the next level of cache, or to main memory, and clearing the dirty bits in the cache line. This makes the contents of the cache line coherent with the next level of the cache or memory system. This is only applicable for data caches in which a write-back policy is used. This is also a way of making changes in the cache visible to the user of the outer memory domain, but is only available for data cache."
from this http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABJDBHI.html

17:0-19:30
Mon Nov 21 16:31:07 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0f990d6_ce72b4c2
UUID: f0e0b014_12beac62
Bytes: 237
Sure, but this doesn't mention memory protection, and you might expect that implicit cache flushes (that happen all the time) do not look at page permissions. So can we conclude that all "dc" instructions do look at the page permissions?

17:0-19:30
Mon Nov 21 17:52:25 2016 +0000
Author: David Sehr <1103743@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0e0b014_12beac62
UUID: f0f990d6_8eb95ccf
Bytes: 403
I'm guessing a bit, but I believe the issue is that the invalidate instructions effectively do "writes" to shared cache levels from the perspective of other cores.  (Clearing the contents of a dirty line throws away the previous contents, and read from memory may yield different values.)  It's possibly the case that the invalidate in the nearest cache is propagated out via write operations as well...

