Revision: 3d937633164210981fbb6ce971918ce274c624ef
Patch-set: 4
File: compiler/optimizing/inliner.cc

263:12-263:25
Mon Nov 28 15:09:06 2016 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d90030a_7f966f9e
Bytes: 221
Having the reference to InlineCache here and in the other Is* methods seems out of the blue and makes the code less readable as you need to wonder 'why do I reference this clas?'. Do the dcheck actually add any value now?

263:12-263:25
Tue Nov 29 10:45:14 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_7f966f9e
UUID: 4d90030a_a25940a7
Bytes: 193
They do add value (showing the query is related to the size of our inline caches).

As discussed, I don't agree it's out of the blue. IsMonomoprhic/Polymorphic are all inline cache terminology.

File: runtime/jit/jit_code_cache.cc

331:17-331:18
Mon Nov 28 13:54:50 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d90030a_5f14cb6c
Bytes: 21
Use a reference here?

331:17-331:18
Mon Nov 28 14:21:21 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_5f14cb6c
UUID: 4d90030a_7f1f4f78
Bytes: 37
It won't be const, so I'd rather not.

331:17-331:18
Mon Nov 28 14:36:20 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_7f1f4f78
UUID: 4d90030a_bf4dd788
Bytes: 119
Your call; but note that the only context where the style guide forbids non-const references is when passing arguments.

343:40-343:56
Mon Nov 28 13:54:50 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d90030a_3f2307ce
Bytes: 10
down_cast?

343:40-343:56
Mon Nov 28 14:21:21 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_3f2307ce
UUID: 4d90030a_5f1a8b89
Bytes: 4
Done

406:8-406:39
Mon Nov 28 13:17:50 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d06c8cba_76e7ae63
Bytes: 60
This seems to be inconsistent with AllowInlineCacheAccess().

406:8-406:39
Mon Nov 28 13:22:01 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d06c8cba_76e7ae63
UUID: 4d90030a_ff56ff47
Bytes: 215
Yeah, I just shared the way you wake up waiting threads between the two configs.

The only difference between the two versions is the update of is_weak_access_enabled_. Do you prefer having it under kUseReadBarrier?

406:8-406:39
Mon Nov 28 14:27:46 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_ff56ff47
UUID: d041ec2c_34ed3646
Bytes: 271
If we're consistently updating is_weak_access_enabled_ even for kUseReadBarrier, why don't we simply return is_weak_access_enabled_ regardless of the configuration? Otherwise the code unnecessarily relies on a specific behavior of Runtime::Allow/DisallowNewSystemWeaks().

406:8-406:39
Mon Nov 28 14:29:27 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d041ec2c_34ed3646
UUID: 4d90030a_df569b21
Bytes: 63
DisallowInlineCacheAccess is not called on read-barrier config.

406:8-406:39
Mon Nov 28 15:49:44 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_df569b21
UUID: 705120f4_93ab5e6f
Bytes: 73
I see (at last). Then just follow Calin's suggestion of adding DCHECK()s.

