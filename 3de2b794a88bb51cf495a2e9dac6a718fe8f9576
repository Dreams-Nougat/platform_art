Revision: 3de2b794a88bb51cf495a2e9dac6a718fe8f9576
Patch-set: 3
File: /COMMIT_MSG

7:22-7:37
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d538656_5b66b71c
Bytes: 51
as Andreas mentioned, it's either correct or not :)

7:22-7:37
Wed Aug 05 09:57:15 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d538656_5b66b71c
UUID: 4a2a60c0_e9525562
Bytes: 4
Done

9:7-9:15
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d335a20_047a1897
Bytes: 213
I don't see an immediate gain for this and we are more verbose. What's the actual benefit? equal instructions returned and HIntConstant before as well based on the previous implementation of the static evaluation?

9:7-9:15
Mon Jul 27 17:15:22 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d335a20_047a1897
UUID: 6dc1fe6b_fa7c29e2
Bytes: 673
Could you rephrase your last sentence?  I had a hard time parsing it. :)

The benefit is that we can properly process operations with different signatures regarding inputs and output, e.g.:

- arithmetic operations: (T, T) → T
- condition (including merged compare & condition) : (T, T) → bool ("converted" to int).
- comparisons: (T, T) → int

So I separated the dispatch part (Evaluate) from the computation part (Compute*), much like the Visitor design pattern does.  Sometimes the latter is the same for all cases; sometimes we have various cases (e.g. ComputeIntegral vs ComputeFP).  See also https://android-review.googlesource.com/#/c/161016 for more examples.

9:7-9:15
Wed Jul 29 18:43:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6dc1fe6b_fa7c29e2
UUID: 4d7fda4c_44ba00ba
Bytes: 102
Sorry for the bad wording.

I missed that actually for HEqual we returned either an int32 or an int64.

File: compiler/optimizing/nodes.cc

1016:5-1016:66
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d48f2a1_db3c934c
Bytes: 42
how about shift which can be "long << int"

1016:5-1016:66
Mon Jul 27 17:15:22 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d48f2a1_db3c934c
UUID: adce96a1_545f6cbc
Bytes: 335
Can this actually happen?  Dex instructions such as shl-int or shl-long expect either two ints or two longs.  Also, the code generators seem to handle only (int, int) and (long, long) cases; e.g. see art::arm::InstructionCodeGeneratorARM::HandleShift.

(And currently the worst case is, this doesn't get optimized by constant folding.)

1016:5-1016:66
Wed Jul 29 18:43:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: adce96a1_545f6cbc
UUID: 0d8962a8_3f6ee722
Bytes: 288
during codegen, for long, the second argument gets a register so maybe this is why is not immediately clear that you can have a HLongConstant << HIntConstatn.

try a simple example:
  public static void main(String[] args) {
    long x = 23l << args.length;
    System.out.println(x);
  }

1016:5-1016:66
Wed Aug 05 09:57:15 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d8962a8_3f6ee722
UUID: ed8faeab_3248d832
Bytes: 176
Thanks for pointing this out Calin!  This can happen with shift and logical operations indeed.  I've addressed those cases and augmented the constant folding test suite in PS8.

File: compiler/optimizing/nodes.h

2052:2-2052:21
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd3e6aec_5dffdbda
Bytes: 4
why?

2052:2-2052:21
Mon Jul 27 17:15:22 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd3e6aec_5dffdbda
UUID: 2dbb86f3_9836559c
Bytes: 240
Note: this was present in the initial code (see Base set, line 2679); I just moved it higher for dependency reasons.

This is required by art::HGraph::GetNullConstant, which instantiates an art::HNullConstant (the ctor of which is private).

2052:2-2052:21
Wed Jul 29 18:43:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2dbb86f3_9836559c
UUID: 4d7fda4c_64c70439
Bytes: 26
thanks. I forgot about it.

2063:11-2063:33
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d335a20_c4983087
Bytes: 68
DCHECK, otherwise we get might get a sigsegv which is less readable.

2063:11-2063:33
Mon Jul 27 17:15:22 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d335a20_c4983087
UUID: 2dbb86f3_782ca14a
Bytes: 177
Note: this was present in the initial code (see Base set, line 2690); I just moved it higher for dependency reasons.

I've added DCHECKs, here and in other HConstant subclasses.

2063:11-2063:33
Wed Jul 29 18:43:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2dbb86f3_782ca14a
UUID: 6d657ec3_1d993789
Bytes: 84
thanks, 

Sometime when stuff gets moved is harder to see what changed and what not.

2261:30-2261:42
Thu Jul 23 16:18:19 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d538656_9b67af15
Bytes: 24
why not HConstant  then?

2261:30-2261:42
Mon Jul 27 17:15:22 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d538656_9b67af15
UUID: 0dbec2e2_37263869
Bytes: 184
Because:
1. I'm using overloading to select the right method here (see TryStaticEvaluation methods);
2. We need the exact type of the concrete classes to be able to call x->GetValue().

2261:30-2261:42
Wed Jul 29 18:43:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0dbec2e2_37263869
UUID: 6d657ec3_3d96fb57
Bytes: 144
I think an HIntConstant here with and if IsIntConstant would save lines when we invokes this. But I dont' mind if you want to keep it like this.

