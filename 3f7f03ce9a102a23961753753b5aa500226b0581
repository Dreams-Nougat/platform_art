Revision: 3f7f03ce9a102a23961753753b5aa500226b0581
Patch-set: 4
File: /COMMIT_MSG

9:52-10:60
Tue Sep 27 20:33:15 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c54be3fb_1bca5b9a
Bytes: 197
Why is DisallowThreadSuspension not good enough? If we already do a pass over all the places where we have mirror::Object* pointers lying around, we could instead just use DisallowThreadSuspension?

9:52-10:60
Tue Sep 27 20:36:45 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c54be3fb_1bca5b9a
UUID: e5c1c7c3_a4bac28b
Bytes: 119
Too hard to put DisallowThreadSuspension at all the right places. Ideally we would have better static analysis support.

9:52-10:60
Tue Sep 27 20:40:02 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e5c1c7c3_a4bac28b
UUID: c54be3fb_fb4f6f34
Bytes: 305
How about a combination of handles and DisallowThreadSuspension? Why would that be harder than replacing all (?) mirror::Object with ObjPtr? Do you have some examples in mind?

Don't get me wrong, I like the idea of better protection mechanism, but having too many can lead to confusion about what to use.

9:52-10:60
Tue Sep 27 20:47:40 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c54be3fb_fb4f6f34
UUID: e5c1c7c3_84318611
Bytes: 230
Don't worry I will convert everything over eventually soon maybe. The main issue I have is that it would require DisallowThreadSuspension in almost every block and it would be hard to reason about the callee / caller relationship.

9:52-10:60
Tue Sep 27 20:54:48 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e5c1c7c3_84318611
UUID: c54be3fb_5b5f83e5
Bytes: 223
OK, I'll trust you can give us a consistent story :)

Can that story be:
1) Never use mirror::Object*
2) Use ObjPtr in places that are performance sensitive, and have no suspension.
3) Use Handles in all other situations

?

File: runtime/class_linker.cc

2381:0-2381:31
Tue Sep 27 14:16:24 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 051b3b2a_157ad4c0
Bytes: 24
Please comment why here.

2381:0-2381:31
Tue Sep 27 16:53:04 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 051b3b2a_157ad4c0
UUID: 05d89b6b_47691288
Bytes: 4
Done

2381:0-2381:31
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_47691288
UUID: 05d89b6b_02a418b4
Bytes: 184
Is there a way to cover all suspend points by instrumenting in a few well-defined points like, for example, CheckSuspend(), TransitionFromRunnableToSuspended() and the allocation path?

2381:0-2381:31
Tue Sep 27 18:13:36 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_02a418b4
UUID: 05d89b6b_76560161
Bytes: 192
Not 100% since things like

if (sometimes) {
DoSuspension();
}
AccessStaleHandle();

Might pass even though they are not correct. I'll try to put this at most places that could cause problems.

File: runtime/mirror/obj_ptr.h

32:31-32:51
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05d89b6b_a2fd449b
Bytes: 42
Comment on where a race condition happens?

32:31-32:51
Tue Sep 27 18:13:36 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_a2fd449b
UUID: 05d89b6b_3660792a
Bytes: 89
I think we only access from a single thread so it should be OK, maybe ill delete comment.

88:47-88:48
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05d89b6b_82348894
Bytes: 43
Maybe also print the pointer value as well?

88:47-88:48
Tue Sep 27 18:13:36 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_82348894
UUID: 05d89b6b_f6bf917a
Bytes: 4
Done

File: runtime/thread-inl.h

62:0-62:25
Tue Sep 27 14:16:24 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c54be3fb_9b366b05
Bytes: 41
And put parts of the commit message here.

62:0-62:25
Tue Sep 27 16:53:04 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c54be3fb_9b366b05
UUID: 05d89b6b_6783ee3e
Bytes: 4
Done

62:0-62:25
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_6783ee3e
UUID: 05d89b6b_62e75cfe
Bytes: 30
Move this into CheckSuspend()?

62:0-62:25
Tue Sep 27 18:15:23 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_62e75cfe
UUID: 05d89b6b_b65fc915
Bytes: 169
AllowThreadSuspension is not called often enough to cause performance problems. I'd rather leave it here have poisoning happen each time AllowThreadSuspension is called.

File: runtime/thread.h

474:0-480:3
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05d89b6b_36d3d9f7
Bytes: 76
Is there a way to turn this into a no-op (no overhead) in a non-debug build?

474:0-480:3
Tue Sep 27 18:13:36 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_36d3d9f7
UUID: 05d89b6b_f68d51e6
Bytes: 187
The test relies on it and I did not disable it for NDEBUG. The current callers are common enough to cause performance problems. For object allocation I will guard it behind kIsDebugBuild.

1539:47-1539:89
Tue Sep 27 17:58:19 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05d89b6b_c2cf307c
Bytes: 91
Why not put this in the packed struct? And how is the cross compilation no-access enforced?

1539:47-1539:89
Tue Sep 27 18:13:36 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05d89b6b_c2cf307c
UUID: 05d89b6b_56f0a555
Bytes: 157
Putting stuff in packed struct can change offsets and require more changes. Only things that are access from compiled code / entrypoints should be there IMO.

