Revision: 529ac3ca9906fc1aee202ff86aad786da375d9b2
Patch-set: 2
File: runtime/utils.h

25:10-25:21
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8ba1acbc_e0cda2ee
Bytes: 17
What is this for?

25:10-25:21
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_e0cda2ee
UUID: eb26a84e_136b2c03
Bytes: 83
The is_unsigned and make_unsigned. Those are template things that manipulate types.

25:10-25:21
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_e0cda2ee
UUID: cb81e44d_f54212d5
Bytes: 18
std::make_unsigned

121
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb26a84e_f3a31014
Bytes: 94
This seems like it will underflow back to 0xFFFFF... for bits==0, you probably don't want that

121
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_f3a31014
UUID: cb81e44d_582c75ba
Bytes: 81
The callers already ensure bits > 0, but I can put in another static_assert here.

121
Wed Feb 18 00:30:38 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb81e44d_582c75ba
UUID: cb81e44d_187b4d55
Bytes: 151
Don't think you can static_assert on bits (unfortunately), but if you do want to add more static_asserts you could add one to check that T is integral.

131:6-131:73
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cb0e44b5_4a023333
Bytes: 67
Add a comment why you need this and the former check is not enough.

131:6-131:73
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_4a023333
UUID: eb26a84e_934dfcb6
Bytes: 13
Former check?

131:6-131:73
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_4a023333
UUID: eb26a84e_d6e92208
Bytes: 108
You can just use std::numeric_limits<T>::min() and max() instead of GetIntLimit, they are constexpr in C++11

131:6-131:73
Wed Feb 18 00:06:13 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_934dfcb6
UUID: cb0e44b5_0a0c3b62
Bytes: 33
kBits == kBitsPerByte * sizeof(T)

131:6-131:73
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_0a0c3b62
UUID: eb26a84e_b64ca688
Bytes: 273
No, that is a corner case that we don't hit and that was excluded before. Normally you call something like T=int32_t and kBits=8,16,24. I just thought it's fine to allow kBits = 8 * sizeof(T) and trivially return true, as the constexpr is inlined and either branch is dead.

131:6-131:73
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_d6e92208
UUID: eb26a84e_d64da287
Bytes: 110
Except that GetIntLimit gives the limit with kBits bits, not the numeric_limits for the actual enclosing type.

131:6-131:73
Wed Feb 18 00:26:37 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_b64ca688
UUID: ebb1480e_fb566fa3
Bytes: 175
Then you need to document that corner case. And with an example of call that requires this check and would not succeed with the limit check.

Having both checks is surprising.

137
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6b90f899_cf4dfd87
Bytes: 108
you may want an is_arithmetic check here to be symmetric with IsInt (which is implicit as part of is_signed)

137
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b90f899_cf4dfd87
UUID: 6b90f899_8f8ff514
Bytes: 28
Shouldn't it be is_integral?

137
Wed Feb 18 00:30:38 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b90f899_8f8ff514
UUID: 6b90f899_0fff8530
Bytes: 86
That should work even better since it probably doesn't need to handle floating values.

140
Wed Feb 18 00:30:38 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb26a84e_16a47a8e
Bytes: 170
The result of "GetIntLimit<...>(kBits+1)" is undefined when kBits == 32 because it will try to do "1 << 32" ; but the right operand must be < sizeof(left operand) && >= 0

145:9-145:18
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8ba1acbc_c0d29e8e
Bytes: 29
Move this in the IsUint call?

145:9-145:18
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_c0d29e8e
UUID: cb81e44d_551c3e10
Bytes: 65
I don't think it's meant that way. I preserved old behavior here.

145:9-145:18
Wed Feb 18 00:06:13 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb81e44d_551c3e10
UUID: cb0e44b5_ea37a70a
Bytes: 119
Meant which way? I'm just suggestion to write the shorter version:

return IsUint<kBits, T>(value < 0 ? -value : value)

145:9-145:18
Wed Feb 18 00:08:09 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb81e44d_551c3e10
UUID: eb26a84e_96316a18
Bytes: 148
IIUC there's undefined behavior when value=0b100000...0 (std::numeric_limits<T>::min()) and it's signed because it will overflow after being negated

145:9-145:18
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_ea37a70a
UUID: cb81e44d_38597146
Bytes: 40
Yeah, moving the ternary in makes sense.

145:9-145:18
Wed Feb 18 00:14:02 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_96316a18
UUID: 6b90f899_ef9a4158
Bytes: 92
It seems there are no users of this anymore, so I might remove to avoid the MIN_VALUE issue.

145:9-145:18
Wed Feb 18 00:17:01 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6b90f899_ef9a4158
UUID: 6b90f899_efb7a1b1
Bytes: 193
Actually, there are users (it's just Eclipse not being able to track it). They are all with 10 or 12 bits, so technically the overflow is fine. However, if there's a suggestion on what to do...

