Revision: 57e83c99dedd4e75f3546ee880d95d15ebabe350
Patch-set: 1
File: runtime/gc/heap.cc

4227:0-4230:81
Mon Oct 10 18:06:45 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff9f98ca_f3d76842
Bytes: 53
Might want to put this in a helper (GetAndOverwrite?)

4227:0-4230:81
Mon Oct 10 18:32:28 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff9f98ca_f3d76842
UUID: ff9f98ca_b614aeb2
Bytes: 4
Done

File: runtime/gc/heap.h

1363:30-1363:45
Mon Oct 10 18:19:29 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff9f98ca_760a4685
Bytes: 16
Delete in ~Heap?

1363:30-1363:45
Mon Oct 10 18:32:28 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff9f98ca_760a4685
UUID: ff9f98ca_367f1eb1
Bytes: 64
It's not really owned by the heap, though. But I guess I should.

File: test/904-object-allocation/src/Main.java

28:0-28:17
Mon Oct 10 18:06:45 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff9f98ca_b34160f6
Bytes: 301
Not entirely sure but couldn't we remove the alloc here and other places since it doesn't survive (IIRC we have some optimization like that)? Would (and should) that cause the event to be skipped?

We could get around this by just adding a native call that is a no-op and calling it with all of these.

28:0-28:17
Mon Oct 10 18:32:28 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff9f98ca_b34160f6
UUID: ff9f98ca_36defeff
Bytes: 143
Good question how allocation tracking *should* interact with LSE.

I'll store into a pre-sized vector. That will ensure it has to be allocated.

