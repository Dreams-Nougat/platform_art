Revision: 5c628bffc62b0ec718bad3ec65375a73615c628b
Patch-set: 1
File: compiler/optimizing/licm.cc

123
Fri Nov 11 14:07:49 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8b5ca306_87d33060
Bytes: 583
We should also make it clear in the comment it's in the loop header only. Since other loop blocks may not be executed. Loop header also rules out that the can-throw instruction can move in front of a try boundary within the loop, since try boundary introduces additional blocks so the can-throw instruction can't be in the loop header. So it rules out something like:
try {
  int i = 0;
  do {
    try {
      i = 1;    // even though there is no field store, following NullCheck should not be hoisted.
    } catch(Exception e) {}
  } while (arr.length < 10)
} catch (Exception e) {}

123
Fri Nov 11 14:16:04 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b5ca306_87d33060
UUID: 8b5ca306_e7130c3c
Bytes: 307
Actually if we have:
i = 0;
try {
  do {
      i = 1;    // even though there is no field store, following NullCheck should not be hoisted.
  } while (arr.length < 10)
} catch (Exception e) {}

That still doesn't look right. Do we guard against this case? Looks like the whole thing can't be in a try block.

123
Fri Nov 11 14:31:30 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b5ca306_e7130c3c
UUID: 8be74356_20c98ab3
Bytes: 307
The "i" at the NullCheck is a constant, i.e. defined before the loop. NullCheck can be hoisted, the environment will contain that constant. (If the assignment was something more complex, say "i = (i + 3) ^ 2", we would not hoist. Simple "i += 1" falls under https://android-review.googlesource.com/301687 .)

123
Fri Nov 11 17:30:39 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b5ca306_e7130c3c
UUID: 8b5ca306_f27f48ca
Bytes: 370
I played around with those cases as well while working on both cls. When we have explicit catches that can see the local i, we don't LICM anyway due to the try boundaries. If we don't have those, so only the method throws, i is not visible, except for possible an environment, which we capture correctly. So perhaps only deopts are a concern if we ever see them in licm.

File: test/625-checker-licm-regressions/src/Main.java

47
Fri Nov 11 10:37:00 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bf54bfd_fe2581c7
Bytes: 214
This test isn't very future-proof. The StaticFieldSet could be hoisted and then the NullCheck+ArrayLength would be hoisted as well. Maybe we should add something like "j = (j+3)^2" and change the store to "sA = j".

47
Fri Nov 11 14:07:49 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bf54bfd_fe2581c7
UUID: 8b5ca306_47c918b2
Bytes: 221
StaticFieldSet can't move so it won't be hoisted.
I tried yesterday to have other patterns and it's quite difficult to allow the NullCheck to be hoisted since it's easy to introduce loop_effects that NullCheck depends on.

47
Fri Nov 11 14:19:42 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b5ca306_47c918b2
UUID: 6bba0f39_6f3d517f
Bytes: 229
Non-volatile StaticFieldSet that always stores the same value and is executed at least once is a perfect candidate for hoisting if there are no other writes to memory observable by other threads. (Not by the current LICM though.)

47
Fri Nov 11 14:23:33 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6bba0f39_6f3d517f
UUID: 2bf2d718_808a18fd
Bytes: 71
Actually, it's not exactly LICM. It's something like LICM-enhanced LSE.

47
Fri Nov 11 17:30:39 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bf54bfd_fe2581c7
UUID: 8b5ca306_b2a31055
Bytes: 169
Well is is a regression test. I also have some follow up tests planned in combination with the other Cl to make sure those are not messed up. Will add those when merged.

