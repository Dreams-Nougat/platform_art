Revision: 6465be1e8d69c23ff76dc30b34e76d85315c67ed
Patch-set: 5
File: compiler/optimizing/code_generator.h

335:20-335:28
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee3cdfcb
Bytes: 9
JitRoots?

File: compiler/optimizing/code_generator_arm.cc

5691:0-5692:53
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_6e17cf60
Bytes: 149
Sharpening does not currently allow such fallback because it determines the address for kDexCacheAddress before calling GetSupportedLoadStringKind().

File: compiler/optimizing/code_generator_mips.cc

4287:0-4287:27
Wed Oct 12 02:34:44 2016 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_aa3c6919
Bytes: 19
Add a TODO comment.

File: compiler/optimizing/code_generator_x86_64.cc

5443
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_9697e196
Bytes: 84
Does it make sense to have 

DCHECK(Runtime::Current()->UseJitCompilation());

here?

File: compiler/optimizing/nodes.h

5725:21-5725:47
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc27a6af_4df09989
Bytes: 146
I don't think this needs an environment, we're using it only when the string is already resolved and then we don't have the slow path with a call.

File: compiler/optimizing/optimizing_compiler.cc

1142:0-1144:98
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee217fbd
Bytes: 116
Can we avoid this temporary storage? For example by writing directly to the literal_data?
(Note: Missing OOM check.)

File: runtime/jit/jit_code_cache.cc

83:2-83:68
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_0e284b87
Bytes: 179
Since we allocate the JIT code and data areas together and within 1GiB, we could use a PC-relative addressing mode on x86-64 if we reserve both data and code area before patching.

288
Tue Oct 11 22:48:50 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_67a36d4c
Bytes: 811
As we discussed previously, it would be ideal if we can assert that accessing the literals while the system weak access is disabled wouldn't cause an object to be marked (as they should be already marked) to sanity-check the rationale behind the special JIT literal handling.

But I think it's not easy to assert that because the reader side doesn't have an easy place to put a DCHECK on (the PC-relative load in the compiled code, or requires an extra special read barrier slow path entrypoint for CC).

Does anyone have an idea of how we can assert that or something close to it?

CC has 

    CHECK(self == thread_running_gc_)
        << "Only GC-running thread should access the mark stack "
        << "in the GC exclusive mark stack mode";

at least even though it doesn't cover the entire window of time.

299:6-299:36
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_d62cf9a1
Bytes: 113
Can we put a comment why this DCHECK holds? Because the strings are always strongly-interned and should be alive?

File: runtime/runtime.cc

488:0-490:3
Tue Oct 11 17:18:00 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_7030909c
Bytes: 164
Please add code comments here (or elsewhere) why you think it's OK to not follow the full system-weak setup (which requires access to be blocked in certain phases).

488:0-490:3
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_7030909c
UUID: 1f7aac68_2c76bcfb
Bytes: 991
I think the rationale that we discussed on why we don't currently need to block access to the literal tables is the following:

The literal classes and strings must be strongly-reachable (from the class loader and from the intern table) and marked by the time the system weaks handling happens. So, it's fine to access the literal system weaks (without getting blocked) while the system weaks handling is ongoing because accessing them doesn't change the liveness of the objects and allows the marking to be safely terminated. In general, accessing a system weak may revive an otherwise dead object into a live object, which would interfere with the termination of marking.

The only exception is the class unloading case for literal classes. But when the literal classes become unreachable as a result of class unloading, we won't be accessing the literal classes because the JIT'ed code that accesses them must not be running at that point because of the class unloading.

Is this correct?

488:0-490:3
Tue Oct 11 22:27:11 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_2c76bcfb
UUID: 1f7aac68_ecd84448
Bytes: 156
I would think that is correct, but it's two long paragraphs and I'd like this to be eternalized (since there is zero documentation about the JIT otherwise).

488:0-490:3
Tue Oct 11 22:29:11 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_ecd84448
UUID: 1f7aac68_c770c134
Bytes: 62
I think we should add a comment about the rationale somewhere.

