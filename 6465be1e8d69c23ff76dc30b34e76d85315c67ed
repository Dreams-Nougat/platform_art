Revision: 6465be1e8d69c23ff76dc30b34e76d85315c67ed
Patch-set: 5
File: compiler/optimizing/code_generator.h

335:20-335:28
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee3cdfcb
Bytes: 9
JitRoots?

335:20-335:28
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c2b9a7f_ee3cdfcb
UUID: 2b6bb700_55968c95
Bytes: 18
Is JitLiterals ok?

335:20-335:28
Tue Nov 08 13:49:15 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2b6bb700_55968c95
UUID: 2b6bb700_bb90af67
Bytes: 233
This creates an ambiguity for the word "literal". Previously, it was used only for data embedded in the code, now you're also using the word for stuff in the metadata. These are weak roots, right? So why not JitRoots or JitWeakRoots?

335:20-335:28
Tue Nov 08 14:58:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2b6bb700_bb90af67
UUID: 0b12739d_6af5b314
Bytes: 19
Done with JitRoots.

File: compiler/optimizing/code_generator_arm.cc

5691:0-5692:53
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_6e17cf60
Bytes: 149
Sharpening does not currently allow such fallback because it determines the address for kDexCacheAddress before calling GetSupportedLoadStringKind().

5691:0-5692:53
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c2b9a7f_6e17cf60
UUID: 2b6bb700_55a04cdd
Bytes: 100
Replace with kDexCacheViaMethod (kDexCacheAddress is dead anyway, I'll remove it in a follow-up cl).

File: compiler/optimizing/code_generator_mips.cc

4287:0-4287:27
Wed Oct 12 02:34:44 2016 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_aa3c6919
Bytes: 19
Add a TODO comment.

4287:0-4287:27
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_aa3c6919
UUID: 6b55af38_3740387c
Bytes: 4
Done

File: compiler/optimizing/code_generator_x86_64.cc

5443
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_9697e196
Bytes: 84
Does it make sense to have 

DCHECK(Runtime::Current()->UseJitCompilation());

here?

5443
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_9697e196
UUID: 2b6bb700_b5b44020
Bytes: 4
Done

File: compiler/optimizing/nodes.h

5725:21-5725:47
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc27a6af_4df09989
Bytes: 146
I don't think this needs an environment, we're using it only when the string is already resolved and then we don't have the slow path with a call.

5725:21-5725:47
Wed Oct 12 12:41:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc27a6af_4df09989
UUID: 5c37d20c_208f4ae1
Bytes: 113
Yup, that's what the code here is doing: return false to NeedsEnvironment if the load kind is kJitTableAddress :)

File: compiler/optimizing/optimizing_compiler.cc

1142:0-1144:98
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee217fbd
Bytes: 116
Can we avoid this temporary storage? For example by writing directly to the literal_data?
(Note: Missing OOM check.)

1142:0-1144:98
Wed Oct 12 12:41:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c2b9a7f_ee217fbd
UUID: 5c37d20c_e0eba267
Bytes: 463
We cannot avoid the temporary storage for now (I'll add a comment). The literal_data will only be visited by GC once the OatQuickMethodHeader is registered within the jit code cache. That only happens during CommitCode (called in this method line 1160).

We can think of how to turn this around, and make the literal_data allocation visible to the GC in a safe way with regards to the jit code cache collection. But I think such a change would deserve its own CL.

File: runtime/jit/jit_code_cache.cc

83:2-83:68
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_0e284b87
Bytes: 179
Since we allocate the JIT code and data areas together and within 1GiB, we could use a PC-relative addressing mode on x86-64 if we reserve both data and code area before patching.

83:2-83:68
Wed Oct 12 12:41:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c2b9a7f_0e284b87
UUID: 5c37d20c_809456f2
Bytes: 256
Good point.

Problem is reserving the code area before patching implies more ScopedCodeCacheWrite windows. Or a refactoring of the code generators to understand there's one buffer where things are emitted, and one final buffer.

I'll add that as a comment.

288
Tue Oct 11 22:48:50 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_67a36d4c
Bytes: 811
As we discussed previously, it would be ideal if we can assert that accessing the literals while the system weak access is disabled wouldn't cause an object to be marked (as they should be already marked) to sanity-check the rationale behind the special JIT literal handling.

But I think it's not easy to assert that because the reader side doesn't have an easy place to put a DCHECK on (the PC-relative load in the compiled code, or requires an extra special read barrier slow path entrypoint for CC).

Does anyone have an idea of how we can assert that or something close to it?

CC has 

    CHECK(self == thread_running_gc_)
        << "Only GC-running thread should access the mark stack "
        << "in the GC exclusive mark stack mode";

at least even though it doesn't cover the entire window of time.

288
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_67a36d4c
UUID: 2b6bb700_75146825
Bytes: 72
Yes, you would need that assert in the compiled code, which isn't ideal.

299:6-299:36
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_d62cf9a1
Bytes: 113
Can we put a comment why this DCHECK holds? Because the strings are always strongly-interned and should be alive?

299:6-299:36
Fri Nov 04 15:15:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_d62cf9a1
UUID: 2b6bb700_150ff414
Bytes: 4
Done

File: runtime/runtime.cc

488:0-490:3
Tue Oct 11 17:18:00 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_7030909c
Bytes: 164
Please add code comments here (or elsewhere) why you think it's OK to not follow the full system-weak setup (which requires access to be blocked in certain phases).

488:0-490:3
Tue Oct 11 22:23:52 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_7030909c
UUID: 1f7aac68_2c76bcfb
Bytes: 991
I think the rationale that we discussed on why we don't currently need to block access to the literal tables is the following:

The literal classes and strings must be strongly-reachable (from the class loader and from the intern table) and marked by the time the system weaks handling happens. So, it's fine to access the literal system weaks (without getting blocked) while the system weaks handling is ongoing because accessing them doesn't change the liveness of the objects and allows the marking to be safely terminated. In general, accessing a system weak may revive an otherwise dead object into a live object, which would interfere with the termination of marking.

The only exception is the class unloading case for literal classes. But when the literal classes become unreachable as a result of class unloading, we won't be accessing the literal classes because the JIT'ed code that accesses them must not be running at that point because of the class unloading.

Is this correct?

488:0-490:3
Tue Oct 11 22:27:11 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_2c76bcfb
UUID: 1f7aac68_ecd84448
Bytes: 156
I would think that is correct, but it's two long paragraphs and I'd like this to be eternalized (since there is zero documentation about the JIT otherwise).

488:0-490:3
Tue Oct 11 22:29:11 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_ecd84448
UUID: 1f7aac68_c770c134
Bytes: 62
I think we should add a comment about the rationale somewhere.

488:0-490:3
Wed Oct 12 12:41:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f7aac68_c770c134
UUID: 5c37d20c_60995226
Bytes: 50
Will do. Note that this is still under discussion.

