Revision: 6465be1e8d69c23ff76dc30b34e76d85315c67ed
Patch-set: 5
File: compiler/optimizing/code_generator.h

335:20-335:28
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee3cdfcb
Bytes: 9
JitRoots?

File: compiler/optimizing/code_generator_arm.cc

5691:0-5692:53
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_6e17cf60
Bytes: 149
Sharpening does not currently allow such fallback because it determines the address for kDexCacheAddress before calling GetSupportedLoadStringKind().

File: compiler/optimizing/nodes.h

5725:21-5725:47
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc27a6af_4df09989
Bytes: 146
I don't think this needs an environment, we're using it only when the string is already resolved and then we don't have the slow path with a call.

File: compiler/optimizing/optimizing_compiler.cc

1142:0-1144:98
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_ee217fbd
Bytes: 116
Can we avoid this temporary storage? For example by writing directly to the literal_data?
(Note: Missing OOM check.)

File: runtime/jit/jit_code_cache.cc

83:2-83:68
Tue Oct 11 17:14:48 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c2b9a7f_0e284b87
Bytes: 179
Since we allocate the JIT code and data areas together and within 1GiB, we could use a PC-relative addressing mode on x86-64 if we reserve both data and code area before patching.

File: runtime/runtime.cc

488:0-490:3
Tue Oct 11 17:18:00 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1f7aac68_7030909c
Bytes: 164
Please add code comments here (or elsewhere) why you think it's OK to not follow the full system-weak setup (which requires access to be blocked in certain phases).

