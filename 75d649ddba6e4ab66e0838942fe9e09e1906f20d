Revision: 75d649ddba6e4ab66e0838942fe9e09e1906f20d
Patch-set: 1
File: /COMMIT_MSG

7:5-7:12
Thu Oct 13 15:11:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7cc1f61c_e95875fa
Bytes: 41
Which part of the code was broken before?

File: compiler/jni/jni_compiler_test.cc

390:3-390:4
Thu Oct 13 08:45:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c37d20c_a3a9a47c
Bytes: 1
2

File: compiler/jni/quick/jni_compiler.cc

326
Thu Oct 13 17:24:18 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bcafeeab_7b9b7f77
Bytes: 152
@ngeoffray:

> Could you point to the code that was broken before?

See this? We set FastStart here regardless of whether or not it returns a reference.

525
Thu Oct 13 17:24:18 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bcafeeab_3ea725a9
Bytes: 792
@ngeoffray:

> Could you point to the code that was broken before?

And here we weren't setting a FastEnd if there were references being returned.

Right. Now if we look at the JNI entrypoint code, a FastStart skips the state transition, but a regular End does not.

In the bug referenced in the commit message, the problem is that we get a LOG(FATAL) when we try to do a state transition from suspended to runnable but we're already runnable.

I initially was setting the FastNative flags lazily so this *just worked* correctly (in End it would've checked it dynamically and skip the state transition) but at some point changed it and never got around to fixing the entrypoints.

I mentioned this on the slides from Tues by the way, just didn't expect to hit this in a real bug the next day.

525
Thu Oct 13 21:50:01 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcafeeab_3ea725a9
UUID: dc63c225_d47bbc45
Bytes: 159
Oh tricky. Things being spread here doesn't really help. You could consider a refactoring where the decisions of which entry points to use are closer together.

525
Thu Oct 13 22:38:12 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc63c225_d47bbc45
UUID: fc73265a_109b2ac6
Bytes: 312
I could factor those out into a helper function something like this

  template <PointerSize kPointerSize>
  ThreadOffset<kPointerSize> GetJniEntrypointOffset(bool is_fast, bool start_or_end, bool reference_return, bool synchronized) {
    // giant if-else here
  }

If that would be an appropriately better way?

File: runtime/thread.h

1505:0-1510:32
Thu Oct 13 08:45:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c37d20c_e3a3ac98
Bytes: 16
Why this change?

1505:0-1510:32
Thu Oct 13 15:08:53 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c37d20c_e3a3ac98
UUID: bcbc4ecf_df564e5e
Bytes: 171
ARM needs 8-byte alignment of thread_local_pos for TLAB, when I added 1 entrypoint only it lost the 8-byte alignment

Andreas said to shuffle some fields around to fix it.

1505:0-1510:32
Thu Oct 13 15:11:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcbc4ecf_df564e5e
UUID: fcac0670_eba3854a
Bytes: 37
Do we have a static_assert somewhere?

1505:0-1510:32
Thu Oct 13 17:24:18 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fcac0670_eba3854a
UUID: bcafeeab_1e2fc9f6
Bytes: 137
runtime/arch/arm/quick_entrypoints_arm.S:#error "Thread::thread_local_pos/end must be consecutive and are 8 byte aligned for performance"

