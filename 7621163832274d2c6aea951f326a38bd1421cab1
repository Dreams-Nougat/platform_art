Revision: 7621163832274d2c6aea951f326a38bd1421cab1
Patch-set: 2
File: compiler/optimizing/code_generator_arm.cc

751
Tue Oct 18 16:00:03 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcaf43ab_bb76a7b8
Bytes: 316
I was wondering whether we needed a DMB ISH barrier here (and one after the loop, on line 780), but because we're implementing a strong CAS with relaxed memory ordering, I thought they were not needed.  (Clang seems to generate similar code, without DMBs, for such a strong relaxed CAS).  Is this a valid assumption?

751
Tue Oct 18 20:21:10 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcaf43ab_bb76a7b8
UUID: dcf58392_de9bc45b
Bytes: 77
I think so, as I understand, we don't need a fence/barrier for a relaxed CAS.

751
Thu Oct 20 14:34:54 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_de9bc45b
UUID: fce08714_ccbf6f07
Bytes: 11
OK, thanks.

File: compiler/optimizing/code_generator_arm64.cc

763:7-763:12
Tue Oct 18 20:21:10 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_f9897a08
Bytes: 133
I think we don't need fences (acquire/release) in this relaxed CAS. Is that what clang emits? Use ldxr/stxr (without fences) instead?

763:7-763:12
Thu Oct 20 14:34:54 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_f9897a08
UUID: 7c0657a0_a89bfbae
Bytes: 1477
Right; I was looking at the code generated by clang++ with `-O0`, which uses LDAXR and STLXR. Higher levels of optimization (`-O1`, `-O2`, `-O3`) indeed use LDXR, STXR and CLREX.

For instance, to implement this compiler (C) builtin call:

  __atomic_compare_exchange(ptr,
                            expected,
                            desired,
                            /* weak */ false,
                            /* success_memorder */ __ATOMIC_RELAXED,
                            /* failure_memorder */ __ATOMIC_RELAXED);

clang++ (namely prebuilts/clang/host/linux-x86/clang-stable/bin/clang++ from AOSP) emits this code with `-O0`:

  // ...  
  .LBB0_1:                                // =>This Inner Loop Header: Depth=1
          ldaxr   w11, [x0]
          cmp     w11, w9
          b.ne    .LBB0_3
  // BB#2:                                //   in Loop: Header=BB0_1 Depth=1
          stlxr   w12, w10, [x0]
          cbnz    w12, .LBB0_1
  .LBB0_3:
          subs    w9, w11, w9
          cset    w10, eq
  // ...

With `-O1`, it becomes:

  // ...  
  .LBB0_1:                                // =>This Inner Loop Header: Depth=1
  	ldxr  w10, [x0]
  	cmp    w10, w9
  	b.ne  .LBB0_3
  // BB#2:                                //   in Loop: Header=BB0_1 Depth=1
  	stxr  w10, w8, [x0]
  	cbnz  w10, .LBB0_1
  	b  .LBB0_4                        // [Branches to `ret` instruction.]
  .LBB0_3:
  	clrex
  // ...  

I'll implement the latter in my next patch set.

