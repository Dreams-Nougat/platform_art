Revision: 9eeda03e40c1f50829e544176a557ee7946a7cd9
Patch-set: 1
File: runtime/indirect_reference_table.cc

83
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_397acaad
Bytes: 80
What if the error message is null, can it just abort with the old messages then?

83
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_397acaad
UUID: bcbe0e35_c67424f6
Bytes: 254
error_msg should not be null. Would it help to state that explicitly in the comments or add a CHECK for it?

I do not want abort to be called in the constructor. What to do about the error should be the responsibility of the caller, not this constructor.

83
Mon Oct 17 15:32:15 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcbe0e35_c67424f6
UUID: 5c6993e3_2c13e73f
Bytes: 19
CHECK would be good

83
Tue Oct 18 14:35:24 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c6993e3_2c13e73f
UUID: dcaf43ab_1b8a3bfd
Bytes: 4
Done

File: runtime/indirect_reference_table.h

267
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_19610e08
Bytes: 251
Can you leave the old IsValid method here?

I think that's a much clearer pattern to use then checking if the error message is non-empty.

  //example
  IndirectReferenceTable irt(&error_msg);
  if (!irt.IsValid()) {
     LOG(ERROR) << error_msg;
   }

267
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_19610e08
UUID: bca52e1d_6b2c21b2
Bytes: 446
The nice thing about using the error_msg to tell if the object is valid is there is no question about lock safety. Are locks required to call IsValid? What if it's called right after the object is constructed?

On the other hand, I can see how calling IsValid explicitly makes the code easier to follow. I switched to using IsValid. I would be interested in your thoughts on whether it is an improvement overall, given the question about locking.

267
Mon Oct 17 15:32:15 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bca52e1d_6b2c21b2
UUID: 5c6993e3_2c9c47a6
Bytes: 1005
IsValid can be documented as being constructed correctly, and not needing any thread checks because it should just be an IsValid const that only reads other const fields.

I'm not sure that as-is an IRT can ever into an invalid state (after the constructor). The most that can happen is that the capacity is full but that's still valid its just that more adds will fail.


-------------------

The other more complicated way is to do something like

   static IndirectReferenceTable* Create(void* storage, ....) {
        auto ptr = new (storage) IndirectReferenceTable(....);
        if (ptr.check_some_field == false) { 
          return nullptr;
        }
        return ptr;
   }
   // also need to call the destructor explicitly then. ugh.

and then that still lets us use in-place storage, but I don't really like this because then the thread.h would  have to change to use char[sizeof(IRT)] as the storage and a bunch of helpers would have to be exposed instead of accessing it directly as a field.

267
Tue Oct 18 14:35:24 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c6993e3_2c9c47a6
UUID: dcaf43ab_fb954f1c
Bytes: 4
Done

268
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_b9655a14
Bytes: 27
nit: one parameter per line

268
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_b9655a14
UUID: bcbe0e35_66645043
Bytes: 4
Done

File: runtime/java_vm_ext.h

49
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_194a6e80
Bytes: 152
Can you add a separate method for this?

   std::unique_ptr<JavaVMExt> Create(Runtime* runtime, ...)

and it will return null if it fails to initialize?

49
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_194a6e80
UUID: bcbe0e35_267ed8b2
Bytes: 19
Good catch, thanks.

File: runtime/jni_env_ext.h

37
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_b93ebae2
Bytes: 9
comments?

37
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_b93ebae2
UUID: bcbe0e35_4685d4b8
Bytes: 63
Can you elaborate on what you're looking for? Is it better now?

37
Mon Oct 17 15:32:15 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcbe0e35_4685d4b8
UUID: 5c6993e3_0cfaa3cc
Bytes: 26
Thanks, it looks good now.

File: runtime/thread.cc

698
Fri Oct 14 15:01:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fc73265a_99565e25
Bytes: 44
Why even have it if it's going to be unused?

698
Mon Oct 17 09:33:17 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fc73265a_99565e25
UUID: bcbe0e35_06575c5b
Bytes: 209
I am preserving the existing behavior of ignoring the error message. I think its worth considering whether the error should be returned or propagated from here, but I would prefer to leave that for a later CL.

698
Mon Oct 17 15:32:15 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcbe0e35_06575c5b
UUID: 5c6993e3_cc034be6
Bytes: 146
Isn't this the same OutOfMemory type of situation? When new thread is allocated it fails to make JNIEnvExt and so can't fully create a new Thread?

698
Tue Oct 18 14:35:24 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c6993e3_cc034be6
UUID: dcaf43ab_1b70fbf7
Bytes: 386
This case corresponds to the case where AttachCurrentThread is called. In that case, we return a JNI error code to indicate an error occurred. As I understand it, the JNI spec says we could additionally throw a Java exception in this case, but the existing behavior was to return a JNI error code without throwing an exception. I would prefer to preserve that existing behavior for now.

698
Tue Oct 18 18:22:28 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcaf43ab_1b70fbf7
UUID: dcf58392_687e5a5f
Bytes: 479
Not throwing is probably fine.

However if we just return the error code and nothing else, even though we're spec-compliant, doesn't it mean that it will just invisibly fail and that's it?

Doesn't it seem like it should log so at least the user can debug somehow?

---
If there's currently no way to recover AttachCurrentThread failure information then it would be good if it at least logged here. The semantics will be preserved then so in that case there would be no downside.

