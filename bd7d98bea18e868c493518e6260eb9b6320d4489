Revision: bd7d98bea18e868c493518e6260eb9b6320d4489
Patch-set: 1
File: /COMMIT_MSG

9:0-11:65
Tue Nov 29 10:01:20 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d90030a_02a90c58
Bytes: 66
Mention the doc and the section describing the new implementation.

File: runtime/gc/heap.cc

3881
Tue Nov 29 21:46:10 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ade97f6b_4248472a
Bytes: 45
Can you describe the new design in a comment?

3882:56-3882:89
Mon Nov 28 19:33:35 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d266fad_e4e75863
Bytes: 406
I think we're OK with Relaxed here. This is performance critical, and IIUC, we only use the result as a hint; there is no correctness issue no matter what value we see here. Since we're not deducing anything important from the value, I don't think memory ordering is required.

In either case, we can presumably end up with two concurrent calls to RequestConcurrentGC or CollectGarbageInternal. Is that OK?

3882:56-3882:89
Tue Nov 29 16:46:40 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d266fad_e4e75863
UUID: 4d90030a_42cdd4c1
Bytes: 349
Having skimmed the documentation for relaxed versus sequentially consistent, I agree that relaxed seems appropriate here.

Are there guarantees that relaxed updates from one thread will eventually be visible to other threads? Is it possible each thread sees its own increments of native_bytes_allocated_ but not any increments done by other threads?

3882:56-3882:89
Tue Nov 29 18:36:31 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_42cdd4c1
UUID: ade97f6b_9fb8ecac
Bytes: 1061
The short answer is that you shouldn't expect sequentially consistent to make things visible much sooner. It's mostly about ordering guarantees with respect to other updates.

The detailed answers here get messy. See e.g.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0062r1.html, which didn't go anywhere. Part of the issue here is that hardware vendors aren't willing to provide much in the way of guarantees, and compiler writers also hate providing guarantees.

But there is a guarantee that you will see updates that "happen before" you.  And there is enough random synchronization in Java programs that that helps. It is also guaranteed that all accesses to a single location like native_bytes_allocated appear to occur in a single global order, consistent with happens-before, but not necessarily consistent with such global orders for other locations.

I attempted to present some general guidelines for weakly ordered atomics in my recent CppCon talk (slides at http://schd.ws/hosted_files/cppcon2016/74/HansWeakAtomics.pdf, talk on YouTube)

3885:35-3885:44
Tue Nov 29 21:46:10 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ade97f6b_622a2b42
Bytes: 34
Why is this compared to max_free_?

3888:33-3888:55
Mon Nov 28 20:31:29 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d266fad_072c9606
Bytes: 86
I might change all of these to relaxed for consistency, though it doesn't matter here.

3899:35-3899:48
Mon Nov 28 15:42:00 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d90030a_dfba1b08
Bytes: 96
Probably this should be specified as a constant or parameter somewhere. I'm open to suggestions.

3903:4-3903:67
Mon Nov 28 19:33:35 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d266fad_c468dcd3
Bytes: 141
If we get two of these concurrently, do we correctly suppress one? That seems like a fairly important and not particularly unlikely scenario.

3903:4-3903:67
Tue Nov 29 16:46:40 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d266fad_c468dcd3
UUID: 4d90030a_e2d18861
Bytes: 206
Briefly skimming the code suggests to me that we would end up running two GCs in a row in this case. I'll try writing a test case that calls RegisterNativeAllocation on multiple threads to see what happens.

3903:4-3903:67
Tue Nov 29 18:36:31 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d90030a_e2d18861
UUID: ade97f6b_bfcbb032
Bytes: 162
If so, we should probably avoid that. E.g. use compare_exchange to reset native_bytes_allocated_, and trigger a GC only if you are the thread that succeeds at it.

3911:2-3912:37
Mon Nov 28 20:31:29 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d266fad_a7028224
Bytes: 880
The down side of this design is that a client that normally manages its own native memory, and only uses Cleaners as a fallback, still regularly triggers Java GCs. I'm not sure how important that is. My a priori inclination would have been to still negate the effect of RegisterNativeAllocation here. That seems to make sense even if we otherwise keep the current design.

My intuition is that we would want to do this only for explicit deallocations, not for those invoked by a Cleaner.

For now, would it make sense to have RegisterNativeFree just do the decrement (probably limited to keep the value non-negative), and remove the RegisterNativeFree call from NativeAllocationRegistry? That removes an empty JNI call, and gives us a clearer path forward if this starts to matter. We'd add a NativeAllocationRegistry version that handles the "expect to deallocate natively" case.

3911:2-3912:37
Tue Nov 29 16:46:40 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d266fad_a7028224
UUID: 4d90030a_e2e8a8f7
Bytes: 752
I think I understand this comment and agree in principle.

For example, we could imagine a user calling RegisterNativeAllocation followed immediately by a matching RegisterNativeFree in a loop. In that case there is no reason to run GC.

If the user never relies on the GC to call RegisterNativeFree, then they don't need to use RegisterNativeAllocation or RegisterNativeFree at all. I'll take a look and see if there are any users who mostly call RegisterNativeFree explicitly, but sometimes rely on the GC to do the cleaning.

I do wonder if its worth worrying about this in practice, given the limited number of users of RegisterNativeAllocation and the subtlety involved in knowing when it is appropriate to call RegisterNativeFree and when not to.

File: runtime/gc/heap.h

1185:17-1185:40
Tue Nov 29 21:46:10 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ade97f6b_c26c57b1
Bytes: 61
Would native_bytes_allocated_since_last_gc_ be a better name?

