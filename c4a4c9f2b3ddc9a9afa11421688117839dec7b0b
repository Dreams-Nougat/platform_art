Revision: c4a4c9f2b3ddc9a9afa11421688117839dec7b0b
Patch-set: 2
File: runtime/gc/heap.cc

3474:4-3474:6
Tue Jan 05 23:27:47 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1773d7_3eaab1ed
Bytes: 8
4 spaces

3512:98-3512:113
Tue Jan 05 23:27:47 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1773d7_be9d61df
Bytes: 16
Line is too long

3807:2-3807:25
Tue Jan 05 23:27:47 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1773d7_5eb8c530
Bytes: 115
Why num_bytes_freed_revoke_? RecordFreeRevoke doesn't currently get called from CC, do we need to add a call there?

3807:2-3807:25
Wed Jan 06 00:24:29 2016 +0000
Author: Richard Uhler <1057373@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1773d7_5eb8c530
UUID: aa1773d7_01d8b016
Bytes: 534
Initially I tried subtracting directly from num_bytes_allocated, but that caused some CHECKs to fail. I thought there might be an invariant that GC should be responsible for updating num_bytes_allocated for all frees, and it appeared to me that num_bytes_freed_revoke_ was an existing mechanism to tell GC that it should update num_bytes_allocated for some frees when it gets around to it.
I have no idea if RecordFreeRevoke needs to be called from CC. Any advice from the GC masters on how to do this properly is greatly appreciated.

