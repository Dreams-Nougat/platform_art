Revision: d25b5ce8418ecdb7b2552bcb30b922a82887b75a
Patch-set: 12
File: /COMMIT_MSG

21:61-21:70
Fri Oct 21 17:46:54 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_ce9ab74c
Bytes: 8
schedule

23:43-23:52
Fri Oct 21 17:46:54 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_8e94bf1d
Bytes: 8
schedule

File: compiler/optimizing/code_generator_arm64.cc

4798:10-4798:30
Fri Oct 21 17:46:54 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_2ea4b38a
Bytes: 93
Always false here. (And you're not actually using the constant division logic in VisitDiv().)

4798:10-4798:30
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c0657a0_2ea4b38a
UUID: fa024ff6_1c2635de
Bytes: 4
Done

File: compiler/optimizing/nodes.cc

1368:0-1383:26
Fri Oct 21 17:46:54 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_8ecb9f3c
Bytes: 26
MoveBefore(cursor->next_);

1368:0-1383:26
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c0657a0_8ecb9f3c
UUID: ba129745_9abb6d70
Bytes: 840
We cannot simply use MoveBefore for instruction scheduling.

MoveBefore() can support moving an instruction to any position within the whole graph, for example it is used by LICM to hoist instruction out of loop into loop header.

MoveBefore() does CanBeMoved() DCHECK before moving, but this concept is not appropriate for instruction scheduling.
For example, HNewArray cannot be moved freely inside the whole graph (like host out of the loop) thus CanBeMoved() returns false for it; but instruction scheduling can move HNewArray inside one basic block.

Iâ€™ve introduced LocalMoveAfter() function to allow moving instruction inside basic block without checking CanBeMoved(). 
I think the CanBeMoved() and MoveBefore/After() interfaces need improve to support different optimization requirements.

Please let me know your opinion on this.

File: compiler/optimizing/prepare_for_register_allocation.cc

171:0-177:12
Fri Oct 21 17:46:54 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_8ef03f76
Bytes: 64
This has been flagged as a bad merge in PS5 but it's still here.

171:0-177:12
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c0657a0_8ef03f76
UUID: daff4b21_3b9457cf
Bytes: 40
Done.
I've fixed this bad merge in PS15.

File: compiler/optimizing/scheduler.cc

47:42-47:43
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1bcbc99_aa882f03
Bytes: 12
remove space

47:42-47:43
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c1bcbc99_aa882f03
UUID: da182b71_b37098f4
Bytes: 4
Done

140:0-143:15
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 613cf0f2_3f6e4773
Bytes: 59
return ContainsElement(node->GetDataPredecessors(), other);

158:0-161:15
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 41b0ccbe_06785a34
Bytes: 60
return ContainsElement(node->GetOtherPredecessors(), other);

199:42-199:45
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_aba1097d
Bytes: 143
Is a trailing separator OK?

I usually do

  const char* separator = "";
  for (...) {
    stream << separator << ...;
    separator = ",";
  }

225:23-225:46
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_4bbc25a4
Bytes: 20
Command line option?

229:2-229:38
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_0bc61d36
Bytes: 63
I don't like static variables. Can this be supplied externally?

282:2-282:31
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_2bcbd93c
Bytes: 121
Drop the pointer. Just

  initial_candidates.assign(candidates_.begin(), candidates_.end());

instead of the `new` below.

337:0-357:3
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1bcbc99_4a973326
Bytes: 132
This looks like it should be handled by the PopHighestPriorityNode(). (Otherwise the "random" scheduler isn't actually that random.)

360
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 613cf0f2_1f73835d
Bytes: 40
Maybe `switch (instruction->GetKind())`?

474:48-474:54
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_ebacf16e
Bytes: 28
unsupported instruction set?

File: compiler/optimizing/scheduler.h

120:31-120:33
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_cec5174a
Bytes: 43
The figure below shows `n1` being selected.

160:0-161:61
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_eea7bba4
Bytes: 21
kArenaAllocScheduling

189:2-189:14
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf663e5_c69864c6
Bytes: 5
const

196:2-196:53
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 011c1460_77978a26
Bytes: 139
I'd prefer

  ArrayRef<SchedulingNode*> GetDataPredecessors() { ... }
  ArrayRef<const SchedulingNode*> GetDataPredecessors() const { ... }

197:2-197:54
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2123d89f_359d90a2
Bytes: 5
ditto

203:2-203:5
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3c7a1f69_d91437b8
Bytes: 191
I assume this should not be negative. So, size_t or uint32_t, the latter is preferable to keep compiler memory usage as low as possible. Same for other fields below and setters/getters above.

204:10-204:19
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_8ecf1f68
Bytes: 10
represents

205:18-205:22
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_6eb50bd3
Bytes: 4
zero

213:60-213:61
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 41260cae_96ad8cd1
Bytes: 31
End the sentence with a period.

217:2-217:15
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf663e5_a68d6882
Bytes: 25
const HInstruction* const

235:54-235:55
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_2ebf13b5
Bytes: 48
I'd go with 4, 2 isn't worth the reserve() call.

247:35-247:36
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c0657a0_0ebc4fbc
Bytes: 21
kArenaAllocScheduling

263:2-263:16
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_4b974526
Bytes: 5
const

272:59-272:60
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 813d64bf_b082b84b
Bytes: 5
const

274:34-274:77
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_4b6e6574
Bytes: 21
const SchedulingNode*

276:35-276:78
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_6b73215d
Bytes: 5
ditto

283
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 011c1460_17cbb63c
Bytes: 46
Do we really need to expose this internal map?

302:23-302:35
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_eba71191
Bytes: 5
const

304:19-304:20
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1bcbc99_ca81e3e3
Bytes: 5
const

306:17-306:18
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 813d64bf_907fb481
Bytes: 5
const

324:50-324:51
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1bcbc99_ea7e271f
Bytes: 8
OVERRIDE

351
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 21ad986a_c581dae3
Bytes: 444
Alternatively, you could let the subclasses hold the container of nodes and have two functions:

  virtual void AddCandidate(SchedulingNode* candidate) = 0;
  virtual SchedulingNode* PopHighestPriorityCandidate() = 0;

(Return `null` from `PopHighestPriorityCandidate()` to indicate we're done.; or count the number of scheduled instructions.)
That way, each subclass can choose a suitable container, for example a heap with its own comparator.

353
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 011c1460_d7ac1e6f
Bytes: 96
`static` instead of `const`; maybe `protected`?

(Unless you take the alternative design above.)

449:0-452:34
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c1bcbc99_8a8bebff
Bytes: 23
Add top-level `const`s.

486
Mon Oct 24 21:04:59 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1c9c045_cbaa555a
Bytes: 5
const

File: compiler/optimizing/scheduler_arm64.h

39:34-39:47
Tue Oct 25 15:50:31 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 411c4caf_a64b66c9
Bytes: 134
"Float"? This applies only to float division, right? (Unlike the kArm64MulFloatingPointLatency that applies to both float and double.)

39:34-39:47
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 411c4caf_a64b66c9
UUID: 9aeeb371_81c89a11
Bytes: 4
Done

96:0-101:21
Tue Oct 25 15:50:31 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 411c4caf_264136a7
Bytes: 30
I'd prefer a switch statement.

96:0-101:21
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 411c4caf_264136a7
UUID: 5af43b41_3f2687e7
Bytes: 146
Done.
I also think switch makes the code look cleaner. In previous patch sets, there is a 'false' in the if ()  which looks quite confusing to me.

File: compiler/optimizing/scheduler_test.cc

112:2-112:47
Tue Oct 25 15:50:31 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 617f90e7_07bc16a3
Bytes: 105
We don't need a vector here.

    HInstruction* block_instructions[] = {
        add1,
        ...
    };

112:2-112:47
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 617f90e7_07bc16a3
UUID: 5af43b41_1f2bc3af
Bytes: 338
I'd like to keep the std::vector here, because it works really well with ReverseRange(Caintainer& c). Please see the ReverseRange() call below.
If we define it as array here, I think the following code has to write as something like 
 ReverseRange<HInstruction*, sizeof(block_instructions)>(block_instructions);
which looks quite awkward.

140:61-140:66
Tue Oct 25 15:50:31 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 617f90e7_c7275e28
Bytes: 16
scheduling graph

141:7-143:11
Tue Oct 25 15:50:31 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 617f90e7_07e5f6c6
Bytes: 85
This is ugly. I'm going to add ReverseRange() helper functions to iteration_range.h .

141:7-143:11
Tue Oct 25 16:02:49 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 617f90e7_07e5f6c6
UUID: a1bb48d0_39fe8ffc
Bytes: 83
https://android-review.googlesource.com/#/c/294269/1/runtime/base/iteration_range.h

141:7-143:11
Fri Dec 09 14:07:23 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a1bb48d0_39fe8ffc
UUID: 5af43b41_df3c3bf4
Bytes: 62
Done.
The new helper functions make code much cleaner. Thanks!

