Revision: d34630c62a3d97dd7402be2e4291d1735a3aff4e
Patch-set: 1
File: runtime/indirect_reference_table.cc

100:51-100:61
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_6d666cd9
Bytes: 79
nit: lets be consistent about calling this prev_state vs bottomIndex everywhere

100
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_4d9c50f9
Bytes: 188
I think you'd want a comment here, with especial emphasis on  why the second || check is necessary.

IIRC it was something about top index staying the same after doing a PopLocalReferences

101:50-101:85
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_68f81a11
Bytes: 245
nit: I personally find !(hole_at_or-above < segment_state_) a bit less confusing to reason about.

Maybe it will make more sense as-is with more comments. The way I thought about it is that "the hole is only valid whilst its under the top index"

102:11-102:19
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_6d84aca3
Bytes: 14
nit: top_index

104:11-104:16
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_2d9904c8
Bytes: 38
nit: new_num_holes is more elucidating

105
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_2da10431
Bytes: 82
nit: Comment here, e.g. "Count null references in current frame = number of holes"

123:8-123:26
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_8d4d98b3
Bytes: 46
nit: confused me, can you just use count here?

126
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_ad8cd4c2
Bytes: 42
Is this ever a problem if prev_state == 0?

126
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_ad8cd4c2
UUID: dcf58392_48f8bea7
Bytes: 259
Not for prev_state. But for the current state. We will always try to recover holes when the table is empty. Considering that the thread code is adding the thread as a local ref, I think this is not important in practice (also, the loop is empty in that case).

127
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_2dfd8400
Bytes: 538
I'm not really sure I understand the hole_at_or_above logic?

Unlike in Remove where it actually sets it to a real index that is a hole, if hole_at_or_above_ == prev_state then it's not set to a real hole. I'm not sure I understand the need for that extra possible semantic value?

In other words why does it need to be so complicated instead of just saying

   size_t new_hole_at_or_above = 0;
   for each hole@index between prev_state and top_index do:
      new_hole_at_or_above = index

   current_num_holes_ = new_hole_at_or_above

?

127
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_2dfd8400
UUID: dcf58392_28bf32b5
Bytes: 283
You don't need to set it to an actual hole. If you did, then you'd have to keep it correct, which means another scan in Add() when filling the hole.

Instead, it "just" denotes the segment that any current_num_holes_ hole is in, which must be invalidated when that segment is popped.

135:41-135:54
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_cd87a05d
Bytes: 23
nit: expected_num_holes

137:43-137:51
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_0d82484c
Bytes: 14
nit: top_index

139:0-144:5
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_0d3a488b
Bytes: 170
nit: This is the same exact code as in RecoverHoleCount, I think if it was extracted into a separate function (e.g. CountCurrentNumberOfHoles()) it would be more readable

139:0-144:5
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_0d3a488b
UUID: dcf58392_08935642
Bytes: 56
I wanted it separate for test clarity, but sure, can do.

149
Tue Oct 18 18:43:35 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_2382b54c
Bytes: 193
I also see no calls anywhere to make this smaller, I think this also needs to shrink occasionally to free up space. Either in GC or when you call remove and the capacity/used ratio is too much.

149
Tue Oct 18 18:55:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_2382b54c
UUID: dcf58392_c303f1b7
Bytes: 157
See the comment in the header. Only upwards right now. That is kinda OK, because we'll madvise away the free parts. Any resizing downwards is follow-up work.

149
Tue Oct 18 20:13:58 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_c303f1b7
UUID: dcf58392_fee4c0f4
Bytes: 86
madvise away is not sufficient on 32-bit because it eats up the virtual address space.

153
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_edcedc3f
Bytes: 257
Why isn't it just using new(nothrow) ? Is it for the name? If it's for the name, I want to know if it's a global/weak/local table specifically and not that it's merely an IRT.

This will waste most of the page if it never grows past 512, I assume that's OK?

153
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_edcedc3f
UUID: dcf58392_a3c7c52f
Bytes: 196
Note that IrtEntry is storing right now 16B. So you're not wasting padding.

And yes, it's for the ashmem naming, so it can be attributed. Specific naming makes sense, but shouldn't be in this CL.

179:9-179:17
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_ed71bc8d
Bytes: 14
nit: top_index

187
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_cdba0075
Bytes: 372
This (and other places resizing fails) should probably be calling FatalError, although I can't say this with 100% confidence

According to JNI spec:

> The VM calls FatalError if no more local references can be created beyond the ensured capacity.

Also did you update EnsureLocalCapacity for this new dynamic capacity? The old code would fail if asking for >512 capacity.

187
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_cdba0075
UUID: dcf58392_a3dea5f5
Bytes: 68
No, EnsureLocalCapacity isn't fixed, yet. That's a dependent change.

195:16-195:32
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_edd89cd7
Bytes: 37
nit: use a variable instead of just 2

266
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_6d45cc5e
Bytes: 190
These names are very confusing, but I see they are the original names.

Can you at least add a comment for them explaining that it's an upper/lower bound and also if its inclusive/exclusive?

266
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_6d45cc5e
UUID: dcf58392_03cfb93d
Bytes: 21
I'll clean things up.

303:29-303:31
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_08a1967a
Bytes: 72
nit: It's actually scanning down from the top, this comment is outdated?

316:65-316:84
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_2800d262
Bytes: 59
Does anyone know why these reads are without read barriers?

353
Mon Oct 24 18:17:11 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a18a68d9_81c19a1f
Bytes: 48
Great this was removed :). Makes things simpler.

File: runtime/indirect_reference_table.h

137
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_cab4a6da
Bytes: 57
This giant block of comments probably needs to be updated

137
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_cab4a6da
UUID: dcf58392_e31eedd4
Bytes: 70
Yes. Please note the RFC state, for the final CL I'll update the blob.

190
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_6ad01209
Bytes: 86
I'd prefer if this was a struct with a name for what the value represents as the field

190
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_6ad01209
UUID: dcf58392_43f70170
Bytes: 98
Ugh, that will require broader changes, or a memset in the functions here. I'll see what I can do.

190
Tue Oct 18 18:43:35 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_43f70170
UUID: dcf58392_43c0a188
Bytes: 134
I think if it was

    struct IRTSegmentState {
          uint32_t topIndex;
    };

then most of the code would be the same as before

190
Tue Oct 18 18:55:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_43c0a188
UUID: dcf58392_23111502
Bytes: 133
I *dislike* that we give a wrong interface to the outside. I want the caller to not pretend that the state is a uint32_t if it isn't.

190
Tue Oct 18 20:04:32 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_23111502
UUID: dcf58392_1e238c6d
Bytes: 544
What do you mean by that?

Everything should use "IRTSegmentState" instead of uint32_t wherever we currently have a cookie.

However I wouldn't bother with that kind of a cleanup right now since it's not really worth it for this change.

You did update a few places to do it already and they're better off for it.


------

Whether it's using a typedef or a struct doesn't seem like it matters too much, in fact with a struct it makes it harder to mix it up with a uint32_t since we can't just convert between one and the other interchangeably.

258
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_cd8200e6
Bytes: 163
This could be a subclass that allows resizing or templates (or both).

Subclasses probably make more sense if we had lock annotations, otherwise it doesn't matter.

258
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_cd8200e6
UUID: dcf58392_a3634557
Bytes: 146
I wanted to keep things structured similarly right now, so that Add and Remove functionality is in one place. If you prefer, I'll break it up now.

336
Tue Oct 18 20:13:58 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_deb464da
Bytes: 122
Why did you remove it from the .h file? It likely won't get inlined into the jni entrypoint if it's in a separate CC file.

362:44-362:54
Tue Oct 18 18:20:34 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_8852a64f
Bytes: 49
There is only 18 bits for tableIndex, is that OK?

362:44-362:54
Tue Oct 18 18:24:10 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_8852a64f
UUID: dcf58392_e806cac9
Bytes: 64
I am thinking this won't work. Also see 360, <65k is not enough.

362:63-362:68
Tue Oct 18 18:26:39 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_08bcf6bc
Bytes: 124
kind_ is 2 bits, serialChunk is 2 bits on non-debug, 3 bits on debug

we should be using 28 bits here and not 18.

Easy fix.

362:63-362:68
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_08bcf6bc
UUID: dcf58392_c330114d
Bytes: 72
Yes, that's my intent. I don't know why serialChunk was ever this large.

366
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_6d95cc18
Bytes: 84
I assume this returns false and set the error message, but maybe update the comment?

369
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_ada69493
Bytes: 9
comments?

396
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_4d11f076
Bytes: 299
I think all of these need comments for what the value represents.

For example it's pretty non obvious current_num_holes_ is only the holes between the current and previous frame.

I'm still not sure what the hole_at_or_above_ means since its only possible values appear to be either 0 or prev_state

396
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_4d11f076
UUID: dcf58392_c3de51c4
Bytes: 107
I want this to be opaque here, it's an implementation detail. There will be a comment blurb in the cc file.

396
Tue Oct 18 18:43:35 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_c3de51c4
UUID: dcf58392_03d69951
Bytes: 133
I don't think that matters, anything in private is an implementation detail, that's just how C++ is. Why not document it here anyway?

398:0-399:29
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_cdb040c6
Bytes: 116
I am not a fan of this, I would prefer if we had lock annotations or at least lock asserts everywhere it made sense.

398:0-399:29
Tue Oct 18 18:34:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_cdb040c6
UUID: dcf58392_a396a5d4
Bytes: 160
That isn't as simple as you think. What is the lock? What you technically want is to store the Thread* here, and compare the Thread that's making modifications.

398:0-399:29
Tue Oct 18 18:43:35 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_a396a5d4
UUID: dcf58392_c3b2d132
Bytes: 138
For global/weak its just the actual mutex lock.

For local IRTs then yes we'd want to compare the thread, but I'm less worried about that.

398:0-399:29
Tue Oct 18 18:55:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_c3b2d132
UUID: dcf58392_03e5f9ee
Bytes: 117
Plan is to not allow resizing for global/weaks, at least with this CL. There will be a kind CHECK in the constructor.

398:0-399:29
Tue Oct 18 20:04:32 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcf58392_03e5f9ee
UUID: dcf58392_9e781c70
Bytes: 58
It's not thread safe to add/remove regardless of resizing.

File: runtime/jni_env_ext.cc

72
Tue Oct 18 18:14:48 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcf58392_a8404250
Bytes: 45
nit: comments for the magic true/false please

