Revision: d8936da27b792d1ca02e59c92456a1a53c7b9905
Patch-set: 20
File: runtime/jit/jit_code_cache.cc

631:3-631:20
Thu Dec 15 12:18:00 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5a199b0d_5740ac73
Bytes: 199
by anyone/anything right? It's not just down to the jit code cache, as the jit code cache doesn't reference it anymore.

Sorry I'm still puzzled. Aren't you using old_method for the new redefinition?

631
Thu Dec 15 19:20:17 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5a199b0d_5740ac73
UUID: da6aeb2c_d2ad4383
Bytes: 452
It's like the "mirror::<whatever>*"s are after suspend. They shouldn't be used since they might point to anything. After this function the 'old_method' ArtMethod is not valid. If any runtime/compiled code outside of the redefinition stuff gets a hold of it then weird things could happen. This comment is saying that we might want to put in some debug checking that these invalid ArtMethods aren't used that way. It's like why we added the ObjPtr type.

631
Fri Dec 16 10:43:31 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: da6aeb2c_d2ad4383
UUID: 5ad35b96_e74e82b2
Bytes: 646
I'm sorry if I keep getting back and forth on this one. It might be something trivial I'm not getting.

So here's what I think I understand

a) old_method is getting redefined, and new_method is the newly allocated obsolete ArtMethod. The JIT needs to update its data structure so that things now reference new_method instead of old_method.

b) old_method will now be the actual redefinition with its CodeItem being the new CodeItem in the redefined dex file.

So far so good?

Given that a) and b) are done sort of atomically (by having all threads suspended), the part I don't understand is why are you saying old_method cannot be used anymore.

631
Fri Dec 16 17:49:50 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5ad35b96_e74e82b2
UUID: 7a51fff3_1ff20f27
Bytes: 470
Okay so the thing is this function only does (a). Once (b) is finished everything is fine but that doesn't happen until we call 'UpdateClass' later in the redefinition procedure. We need to be sure to cleanup if we return between the end of this function and calling updateClass successfully. 

In many places it is useful for debugging to mark even temporarily invalid objects in order to ease debugging in case they ever escape. That is what this TODO is referring to.

File: runtime/openjdkjvmti/ti_redefine.cc

685:0-688:5
Fri Dec 16 10:43:31 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: daa58b1c_6b026174
Bytes: 200
This made me think about another problem: the jit code cache may already have a profiling info and compiled code (and osr) for this method. And I couldn't find a place where you discard those entries.

688
Fri Dec 16 17:49:50 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: daa58b1c_6b026174
UUID: 7a51fff3_1f404f73
Bytes: 32
I'll look at this in the revert.

