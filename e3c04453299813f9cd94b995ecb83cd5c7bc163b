Revision: e3c04453299813f9cd94b995ecb83cd5c7bc163b
Patch-set: 3
File: runtime/mirror/dex_cache.h

440:6-440:35
Tue Dec 06 19:43:55 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad833f54_bb047bc8
Bytes: 233
Is it better to use a different type? In the future, this is likely to allow accidental access through the normal standard library mechanism, which may rely on locks instead, and thus wouldn't provide atomicity with respect to these.

440:6-440:35
Tue Dec 06 20:01:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad833f54_bb047bc8
UUID: 0d5d2bd4_e5bc96a0
Bytes: 198
In future, when normal 16-byte atomics are supported by the standard library, this workaround should go away. There is no reason why we should have 2 different ways to performing the same operation.

440:6-440:35
Wed Dec 14 01:33:22 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d5d2bd4_e5bc96a0
UUID: da6aeb2c_f2b5f6ab
Bytes: 450
I remain nervous about relying on the fact the the compiler is broken to ensure that this doesn't get mixed with conventional atomic accesses.

If you really want to avoid locks here, then I'm not sure this "workaround" can ever go away. I would personally not want a compiler to use this implementation implicitly, since it requires that loads have write permission. The "fixed" compiler may well use an underlying lock table (as it already should).

440:6-440:35
Wed Dec 14 11:27:52 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: da6aeb2c_f2b5f6ab
UUID: 7aa1ffa9_102c44c8
Bytes: 79
Why is it so wrong for a compiler to assume that you have the write permission?

440:6-440:35
Wed Dec 14 18:35:19 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7aa1ffa9_102c44c8
UUID: da6aeb2c_e539ad01
Bytes: 798
This is all well beyond any standard, so "wrong" is too strong. But it breaks code that I would expect to work, at least if is_lock_free() is true. Do you know if it does?

If I use atomics in a shared memory segment to communicate with another process, it's perfectly reasonable to map the segment read-only, and read from atomics.

Having is_lock_free return true and read-only accesses cause cache contention also seems really questionable.

With this implementation, it's also not at all clear what you can possibly do if some joker uses a load on a 16-bit volatile atomic. Generating a store really seems to be against the rules.

Let me start an external email discussion on this issue. This is an ABI (and maybe API) issue, so I think it's really ARM's (and maybe WG21s) job to resolve this.

