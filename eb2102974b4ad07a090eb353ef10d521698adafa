Revision: eb2102974b4ad07a090eb353ef10d521698adafa
Patch-set: 2
File: /COMMIT_MSG

10:0-10:6
Mon Dec 05 11:20:06 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d0ba3a9_67f1b224
Bytes: 7
entries

10:0-10:6
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d0ba3a9_67f1b224
UUID: 8d159bc1_201829ed
Bytes: 4
Done

File: runtime/class_linker.cc

1898:4-1898:25
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_a328b697
Bytes: 28
Why need to avoid buffering?

1898:4-1898:25
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_a328b697
UUID: 8d159bc1_605ce19b
Bytes: 141
The class table uses a temporary GcRoot for holding the root, the buffered root visiting would access a stale stack location for this object.

1898:4-1898:25
Tue Dec 06 18:50:40 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_605ce19b
UUID: ad833f54_b8280198
Bytes: 114
Which temporary GcRoot? What function/code is this referring to?

Leave a comment why buffering doesn't work here?

1898:4-1898:25
Tue Dec 06 19:25:41 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad833f54_b8280198
UUID: ad833f54_bb91db33
Bytes: 4
Done

1898:4-1898:25
Tue Dec 06 19:42:36 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad833f54_bb91db33
UUID: ad833f54_5b3d4f7e
Bytes: 48
What was done? PS4 doesn't have any change here.

1898:4-1898:25
Tue Dec 06 19:43:42 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad833f54_5b3d4f7e
UUID: ad833f54_1b14a7f5
Bytes: 3
Ps3

File: runtime/class_table-inl.h

81:0-83:86
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_230726fa
Bytes: 132
Do we need to do an update in Read() instead of simply delegating it to VisitRoot() just like a normal concurrently-handled GC root?

81:0-83:86
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_230726fa
UUID: 8d159bc1_004405b6
Bytes: 81
How would read know how to updated the table slot? Can you clarify what you mean?

81:0-83:86
Tue Dec 06 18:50:40 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_004405b6
UUID: ad833f54_d89065a3
Bytes: 390
Is this like the normal read barrier where it has a choice between updating the field when it's triggered versus not updating and relying on the GC to update the field later? My understanding is that this code chose the former. But it could also choose the latter?

IOW, if we don't do this CAS here in READ() and rely on VisitRoot() below to update the pointer later, would that also work?

81:0-83:86
Tue Dec 06 19:25:41 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad833f54_d89065a3
UUID: ad833f54_1bb6e7bb
Bytes: 65
True, we could just not do the CAS and maybe do extra slow paths.

File: runtime/class_table.cc

35:2-35:46
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_3e3dfded
Bytes: 341
Just checking if it's as intended:

1. The old code used to try to find it and it checked the class references are actually equal. Now we don't. Is this okay?

2. If we now just check that the given class is in the class_set, calling LookupByDescriptor would have a redundant read barrier (it->Read())? We could avoid that read barrier here?

35:2-35:46
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_3e3dfded
UUID: 8d159bc1_de47016d
Bytes: 143
Good point, I will revert the behavior here just in case. I don't think having duplicate classes with the same descriptor should happen though.

35:2-35:46
Tue Dec 06 18:50:40 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_de47016d
UUID: ad833f54_78cff9b9
Bytes: 7
Agreed.

File: runtime/class_table.h

45:8-45:17
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_7eb6d58e
Bytes: 55
Do we have some unit tests covering TableSlot/ClassSet?

45:8-45:17
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_7eb6d58e
UUID: 8d159bc1_007f65ca
Bytes: 14
Working on it.

54
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_c38a8a6c
Bytes: 92
Is it possible to DCHECK that 'descriptor_hash' matches the descriptor hash of 'klass' here?

54
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_c38a8a6c
UUID: 8d159bc1_20c5c9f4
Bytes: 4
Done

65:13-65:17
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_9e6aa926
Bytes: 108
Would changing this to "static uint32_t Hash(uint32_t)" avoid having to put "& kHashMask" in many locations?

65:13-65:17
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_9e6aa926
UUID: 8d159bc1_40d0bdb7
Bytes: 4
Done

89:29-89:34
Sat Dec 03 01:01:04 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d159bc1_e356aeeb
Bytes: 60
Make it clearer that this contains a GC root in the comment?

89:29-89:34
Tue Dec 06 02:43:39 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d159bc1_e356aeeb
UUID: 8d159bc1_60cbc10b
Bytes: 4
Done

