Revision: f24525e5d9d9dccbec9ead7b0d352f77961b98e0
Patch-set: 12
File: compiler/optimizing/intrinsics_arm64.cc

57
Tue Jan 27 16:57:46 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cb69dfa3_0d7bc1ac
Bytes: 290
Move this to code_generator_arm64.h?
We already define:
48 const vixl::Register tr = vixl::x18;        // Thread Register 

And we can make use of this in code_generator_arm64.cc too.

Sorry for this I have missed it in my previous comments. I can include this as part of one of my patches.

82
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: abd02b89_319bb280
Bytes: 258
Is it not safe to ignore
  mov w0, w0
?
If it is safe, we need to add `kDiscardForSameWReg` as the last parameter of the move.

Note that executing the 'mov w0, w0' instruction has the side effect of clearing the top 32 bits of x0. I think it should be safe.

100
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_157db69c
Bytes: 103
Just a note: at some point we will want to optimise this to use LDP and STP (load pair and store pair).

100
Tue Jan 27 16:11:10 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2bab5bf1_157db69c
UUID: d7e7c792_97dd761f
Bytes: 70
That should be transparent and in the move resolver, not here, though.

100
Tue Jan 27 16:49:11 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7e7c792_97dd761f
UUID: abd02b89_11014e78
Bytes: 20
Agreed with Andreas.

100
Wed Jan 28 10:47:13 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: abd02b89_11014e78
UUID: 578037c4_f6a140bd
Bytes: 131
And I agree also! The idea has always been to improve the code generated by the resolver without requiring any changes to the user.

230
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cb69dfa3_c2819865
Bytes: 56
Here and in other places: what about `kNoOutputOverlap`?

230
Tue Jan 27 16:11:10 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb69dfa3_c2819865
UUID: d7e7c792_b7407a23
Bytes: 145
Once somebody can tell me what that would actually change, maybe. Right now I don't see any use, and can't really say whether I want to force it.

230
Tue Jan 27 16:49:11 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d7e7c792_b7407a23
UUID: 2bab5bf1_757a3a26
Bytes: 167
Yeah, I'm currently implementing it. It currently has no effect on the register allocator. Once it does, it means the output can share the same register with an input.

241
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_f54e2a89
Bytes: 41
Was that a comment for x86? If so remove.

280
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_d5532e2f
Bytes: 52
Here and in other places: why 'size' and not 'type'?

315:86-315:95
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_35b27208
Bytes: 361
I'm fine if it stays like this, but as a note, in VIXL we generally shorten MacroAssembler to masm. Assembler refers to a parent class of the MacroAssembler. The Assembler can only generate 'real' instructions, while the MacroAssembler takes care of a lot of things for the user (eg. constants that don't fit in immediate fields, or optimising away mov x1, x1).

884
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cb69dfa3_623d2cfb
Bytes: 153
This function generates code for a compare exchange, isn't it?
Can we use LDXR and STXR in the loop, and have a DMB before loop_head and after exit_loop?

884
Tue Jan 27 16:11:10 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb69dfa3_623d2cfb
UUID: b7ec137b_1644ca88
Bytes: 203
That's counter to what happened in Quick. There we started with the purely exclusive loads, but went to acquire-release. Note that a certain S. Constantinescu was the one to suggest and implement that...

884
Tue Jan 27 16:57:46 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb69dfa3_623d2cfb
UUID: abd02b89_51710677
Bytes: 259
This is what Quick does now. Since I expect the default case to be one where the exclusive store succeeds (no retry) - this variant should, at least in theory, be faster.

We can however have a !kUseAcquireRelease variant that is implemented as you suggested.

884
Tue Jan 27 17:03:06 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: abd02b89_51710677
UUID: abd02b89_d1d0568e
Bytes: 264
For now it is fine like this. Please note that for the Optimizing compiler we prefer Load-Acquire Store-Release over the DMB variants, wherever the two can be replaced.

For Nicolas, Andreas - we expect newer CPUs to have a faster implementation for this semantic.

884
Wed Jan 28 11:15:02 2015 +0000
Author: Will Deacon <1065463@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: abd02b89_d1d0568e
UUID: f79dab26_1bfe5b74
Bytes: 549
You're missing a subtlety here in that DMB; LDXR; ...; STXR; DMB has stronger ordering guarantees than the corresponding LDAXR; ...; STLXR sequence.

For example, if A() and B() consist of standard LDR/STR instructions then:

A()
DMB
LDXR
...
STXR
DMB
B()

Requires A() to be globally observed before B(). However:

A()
LDAXR
...
STLXR
B()

Permits B() to be observed before A().

So the question really is: what memory ordering semantics do you require for your cmpxchg? If you define that, then we can come up with an optimal instruction sequence.

959
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_f522aa92
Bytes: 105
Here and below: HeapOperand() ?
You could even pass thee offsets without calling the Int32Value() member.

979
Tue Jan 27 15:22:41 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2bab5bf1_153ad6b5
Bytes: 31
Should there be a 'LOG(FATAL)'?

979
Tue Jan 27 16:11:10 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2bab5bf1_153ad6b5
UUID: 57fbd733_c48fd28c
Bytes: 94
No. Otherwise the compiler will abort every time you hit one. Which is pretty much guaranteed.

979
Wed Jan 28 10:47:13 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 57fbd733_c48fd28c
UUID: f79dab26_fb460f41
Bytes: 95
Ok. I thought they wouldn't be hit if they weren't implemented. I need to check how it works :)

