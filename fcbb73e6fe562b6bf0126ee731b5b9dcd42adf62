Revision: fcbb73e6fe562b6bf0126ee731b5b9dcd42adf62
Patch-set: 1
File: compiler/jni/quick/x86/calling_convention_x86.cc

96:37-96:64
Thu Jan 29 08:50:20 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 97662f11_7b419b5b
Bytes: 83
This still feels odd. I'd DCHECK that after the if and if it trips, figure out why.

96:37-96:64
Thu Jan 29 12:47:53 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 97662f11_7b419b5b
UUID: 37690307_3b0f7f2d
Bytes: 143
I was actually debugging through here, and IsCurrentParamALong() DOES return true for a reference parameter in x86.  I will have a look at why.

96:37-96:64
Thu Jan 29 13:42:01 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 37690307_3b0f7f2d
UUID: 37690307_1bb0c3dd
Bytes: 388
Here is the problem:
  bool IsParamALong(unsigned int param) const {
    DCHECK_LT(param, NumArgs());
    if (IsStatic()) {
      param++;  // 0th argument must skip return value at start of the shorty
    } else if (param == 0) {
      return true;  // this argument
    }
    return shorty_[param] == 'J';
  }

Why does it return true for 'this argument'?  I will try changing to false.

133:47-133:71
Thu Jan 29 08:50:20 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 97662f11_1b365f13
Bytes: 5
ditto

File: runtime/entrypoints/quick/quick_trampoline_entrypoints.cc

62:0-62:60
Thu Jan 29 08:50:20 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f79dab26_ded0e101
Bytes: 30
Please avoid double negatives.

62:0-62:60
Thu Jan 29 12:47:53 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f79dab26_ded0e101
UUID: 37690307_7b19f775
Bytes: 155
NOt a double negative in my mind.  What about
kSplitPairAcrossRegisterAndStack = true for this case?
kRegisterPairSpansLastArgumentRegisterAndStack = true?

62:0-62:60
Thu Jan 29 12:59:07 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 37690307_7b19f775
UUID: 97662f11_3b1483ec
Bytes: 202
Maybe it's 1.5 negative then :-) The thing is *Dont* = whatever makes my mind always go to the positive.

In any case, arm doesn't split the long on our hardfloat ABI, why do you need that flag for x86?

62:0-62:60
Thu Jan 29 13:24:01 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 97662f11_3b1483ec
UUID: 97070f52_f076c06d
Bytes: 177
ARM uses a different flag: kAlignPairRegister.  Unfortunately, this isn't applicable to X86.

Is it better to just change the behaviour without a flag?  I didn't like that idea.

